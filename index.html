<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Signal Plan Checker 2.0.0</title>
<style>
:root{--bg:#ffffff;--card:#f8f9fb;--line:#e8e8e8;--ink:#222;--muted:#666;--accent:#0a66ff;--errbg:#fff4f4;--errbd:#f5c2c7;--errink:#842029}
*{box-sizing:border-box} html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;height:100%}
header{padding:14px 16px;border-bottom:1px solid var(--line);background:#fafafa}
h1{font-size:18px;margin:0} small.muted{color:var(--muted)}
main{height:calc(100vh - 60px);display:grid;grid-template-rows:auto 1fr;gap:10px;padding:10px}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
.card{background:var(--card);border:1px solid var(--line);border-radius:10px;padding:10px}
.alert{display:none;margin:8px 0;padding:10px 12px;border:1px solid var(--errbd);background:var(--errbg);color:var(--errink);border-radius:8px}
.alert.show{display:block}
.tabs{display:flex;gap:6px;margin-top:6px;flex-wrap:wrap}
.tab{padding:8px 10px;border:1px solid var(--line);border-bottom:none;border-radius:8px 8px 0 0;background:#f1f3f6;cursor:pointer}
.tab.active{background:#fff}
.tabpanel{display:none;border:1px solid var(--line);border-radius:0 10px 10px 10px;padding:10px;background:#fff;max-height:40vh;overflow:auto}
.tabpanel.active{display:block}
.grid{border-collapse:collapse;width:100%} .grid th,.grid td{border:1px solid #eee;padding:6px 8px;font-size:12px;text-align:center} .grid th{background:#f7f7f7}
button{padding:8px 10px;border:1px solid #d0d0d0;border-radius:8px;background:#f7f7f7;cursor:pointer;transition:box-shadow .15s,border-color .15s}
button.dirty{border-color:var(--accent); box-shadow: 0 0 0 3px rgba(10,102,255,.15)}
button:disabled{opacity:.55; cursor:not-allowed}
label{display:flex;flex-direction:column;font-size:12px;gap:4px}
input[type=number], select{padding:6px 8px;border:1px solid #d6d6d6;border-radius:6px;min-width:70px}
.badge{padding:2px 6px;border-radius:6px;background:#eef1ff;border:1px solid #dbe1ff;font-size:12px}
#plotPanel{display:grid;grid-template-rows:auto 1fr;gap:8px;height:100%}
#plotToolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
#hiddenWrap{border:1px dashed #bbb;border-radius:8px;background:#fff;overflow:hidden;position:relative;height:100%}
.plot-row{display:flex;align-items:stretch}
#timelineScroll{overflow:hidden;flex:1 1 auto;min-width:0;-webkit-overflow-scrolling:touch;overscroll-behavior:contain;touch-action:none}
#labelCanvas{display:block;flex:0 0 120px;width:120px;background:#fff}
#hiddenCanvas{display:block;width:100%;height:auto;image-rendering:crisp-edges}
#visibleWrap{border:1px solid #bbb;border-radius:8px;background:#fff;overflow:auto;position:relative}
#visibleCanvas{display:block;image-rendering:crisp-edges}
#debugPanel
{ max-height:40vh;
  overflow:auto;
  background:#0d1117;
  color:#c9d1d9;
  border:1px solid #30363d;
  border-radius:10px;padding:8px;font-family:ui-monospace,Consolas,Monaco,monospace
}

/* Overlay modal */
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:10000}
.modal-backdrop.show{display:flex}
.modal-card{width:min(720px,90vw);max-height:80vh;overflow:auto;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
.modal-card header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--line)}
.modal-card .body{padding:12px 14px}
.modal-card footer{display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid var(--line)}
.modal-card h3{margin:0;font-size:16px}
.modal-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.modal-grid label{font-size:12px}
.modal-grid input[type=number], .modal-grid select, .modal-grid input[type=color]{width:100%}

.logline.info{color:#a5d6ff} .logline.warn{color:#ffd27f} .logline.err{color:#ffb4b4}
.infochip{padding:4px 8px;border-radius:999px;border:1px solid #e0e0e0;background:#fff;font-size:12px}
#twoCols{display:grid;grid-template-columns:1fr;gap:10px;height:100%}
</style>
</head>
<body>
<header>
  <h1>Signal Plan Checker <small class="muted">2.0.0</small></h1>
  <div class="row"><span class="badge">Min-green + queued (hidden)</span><span class="badge">Transfer-ready visible canvas</span></div>
</header>
 
  <div class="tabs" id="masterTabs" style="margin:8px 10px 0">
    <button class="tab active" id="tabDataBtn">Data</button>
    <button class="tab" id="tabPlotBtn">Plot</button>
    <button class="tab" id="tabDebugBtn">Debug</button>
  </div>

<main>
  <section class="card">
    <!-- data panel -->
    <!-- Was the main data input card; give it an id so we can toggle tabs -->
    
    
    
    <div id="bootAlert" class="alert"></div>
    <div class="row">
      <span class="badge">Init auto-loaded</span>
      <label>Main cycle (s)<input id="mainCycle" type="number" min="1" max="240" value="60"/></label>
      <label>Junctions<input id="jCount" type="number" min="2" max="5" value="3"/></label>
      <label>View cycles
        <select id="viewCycles">
          <option value="1">1</option><option value="2" selected>2</option><option value="3">3</option>
        </select>
      </label>
  <button id="validateBtn">Validate</button>
  <button id="plotBtn" disabled>Plot</button>
      <span id="statusChip" class="infochip">Waiting for Validate…</span>
    </div>
    <div class="tabs" id="jtabs"></div>
    <div id="tabpanels"></div>
  </section>

  <section id="plotPanel" class="card" style="display:none">
    <div id="plotToolbar">
      <strong>Hidden Extended Canvas (dev)</strong>
      <label>Zoom (px/s)<input type="range" id="zoom" min="1" max="12" step="1" value="4"/></label>
      <button id="fitBtn">Fit</button>
      <button id="overlayBtn">Overlays…</button>
      <span id="info" class="badge">—</span>
    </div>
    <div id="twoCols">
      <div style="display:flex;flex-direction:column;height:100%">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
          <strong>Hidden</strong><span class="badge">full horizon</span>
        </div>
        <div id="hiddenWrap">
          <div class="plot-row">
            <canvas id="labelCanvas"></canvas>
            <div id="timelineScroll">
              <canvas id="hiddenCanvas"></canvas>
            </div>
          </div>
        </div>
      </div>
      <!-- Visible canvas removed: using hidden canvas only -->
    </div>
  </section>
  <section id="debugPanel" class="card" style="display:none">
    <div class="row">
      <button id="dbgClear">Clear</button>
      <span>Debug Log</span>
    </div>
    <div id="log"></div>
  </section>
</main>


<script>
const App = { initCfg:null, state:{ validOk:false, readyToPlot:false, pxPerSec:8, viewStartSec:0, didAutoFit:false } };

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

function setViewStart(newStart){
  const M = App.state.mainCycle;
  const mult = (App.initCfg.plot && App.initCfg.plot.hiddenWindowMultiplier) || 5;
  const T = M * mult; // total seconds
  const C = document.getElementById('hiddenCanvas');
  const viewportSec = (C && C.width ? (C.width / (App.state.pxPerSec||1)) : 0);
  App.state.viewStartSec = clamp(newStart, 0, Math.max(0, T - viewportSec));
}

// Helper: measure the viewport width (px) excluding the label gutter
function measureViewportPx(){
  const ts = document.getElementById('timelineScroll');
  const w = ts ? Math.max(0, Math.floor(ts.getBoundingClientRect().width)) : 0;
  return Math.max(100, w);
}

// Compute vertical layout for hidden/label canvas: expand to fill, distribute rows/gaps
function computeVerticalLayout(){
  const plotCard = document.getElementById('plotPanel');
  const toolbar  = document.getElementById('plotToolbar');
  const wrap     = document.getElementById('hiddenWrap');
  const topPad   = App.initCfg.plot.topMargin || 24;
  const bottomPad= 20;
  const n        = (App.state && App.state.junctions ? App.state.junctions.length : 0) || 1;
  const minRow   = Math.max(24, App.initCfg.plot.rowHeight || 48);
  const minGap   = Math.max(8,  App.initCfg.plot.rowGap || 18);

  // Cap the canvas area to a fraction of the viewport height (configurable, default 65%)
  const vhFrac   = (App.initCfg.plot && App.initCfg.plot.maxHeightVH ? App.initCfg.plot.maxHeightVH : 0.65);
  const maxPx    = Math.floor(window.innerHeight * Math.max(0.3, Math.min(0.95, vhFrac)));

  // Measure the visible space inside the Plot card, below the toolbar
  const panelH   = plotCard ? Math.floor(plotCard.getBoundingClientRect().height) : window.innerHeight;
  const toolH    = toolbar ? Math.floor(toolbar.getBoundingClientRect().height) : 0;
  const padH     = 24; // internal padding/margins within the card

  // Usable height is min(panel content area, viewport cap, current wrapper height)
  const wrapHRaw = wrap ? Math.floor(wrap.getBoundingClientRect().height) : panelH;
  const contentH = Math.max(120, Math.min(maxPx, panelH - toolH - padH, wrapHRaw));

  let rowH = minRow, gap = minGap;
  const avail = Math.max(50, contentH - topPad - bottomPad);

  if(avail >= n * minRow){
    // keep bars at configured height, distribute extra into the gaps evenly
    gap = Math.max(minGap, Math.floor((avail - n*minRow) / Math.max(1,(n-1))));
  }else{
    // not enough space: keep a minimum gap and shrink rows uniformly
    gap = minGap;
    rowH = Math.max(16, Math.floor((avail - (n-1)*gap) / n));
  }

  const totalH = topPad + n*rowH + Math.max(0,(n-1))*gap + bottomPad;
  return { top: topPad, rowH, gap, totalH };
}

function setDirty(){
  const v=document.getElementById('validateBtn');
  const p=document.getElementById('plotBtn');
  const x=document.getElementById('transferBtn');
  if(v) v.classList.add('dirty');
  if(p){ p.classList.add('dirty'); p.disabled = true; }
  if(x){ x.disabled = true; }
  App.state.validOk=false;
  App.state.readyToPlot=false;
  const chip=document.getElementById('statusChip');
  if(chip) chip.textContent='Changes detected — Validate required';
}

function log(msg, level){
  try{
    const box=document.getElementById('log'); if(!box) return;
    const d=document.createElement('div'); d.className='logline '+(level||'info'); d.textContent='['+new Date().toLocaleTimeString()+'] '+msg;
    box.appendChild(d); box.scrollTop=box.scrollHeight;
  }catch(e){}
}
window.addEventListener('error', e=>log('ERROR: '+(e.message||e.error),'err'));
window.addEventListener('unhandledrejection', e=>log('PROMISE: '+(e.reason&&e.reason.message?e.reason.message:e.reason),'err'));

async function loadBundledInit(){
  try{
    const res = await fetch('init.config.json',{cache:'no-store'});
    if(!res.ok) throw new Error('init.config.json not found');
    return await res.json();
  }catch(e){
    return {"appName": "Signal Plan Checker", "ui": {"debug": {"enabled": true, "dock": {"showOnLoad": true}, "logLevel": "info", "validationOnActions": false, "perfMarkers": true}}, "mainCycleTime": {"default": 60, "min": 1, "max": 240, "mustBeEvenWhenAnyDouble": true}, "junctionCount": {"default": 3, "min": 2, "max": 5}, "doubleCycle": {"allowed": true, "requireAtLeastOneMainCycle": true}, "stageCount": {"default": 2, "min": 2}, "stage": {"minGreen": {"default": 7, "min": 1}}, "intergreen": {"diagonalLockedValue": -1, "allowNotPermittedValue": -1, "defaults": {"offDiagonal": 5}, "domain": {"min": 0, "max": 60}}, "journeyTime": {"default": 20, "min": 0, "max": 60}, "utcPlan": {"requireAtLeastOneChange": true, "markRequestsBlue": true, "showQueuedChangeMarkers": true, "warnOnDelay": true, "alertOnMissedChange": true, "defaults": [{"to": "S1", "at": 0}, {"to": "S2", "at": 30}]}, "plot": {"hiddenWindowMultiplier": 5, "viewCycles": {"options": [1, 2, 3], "default": 2}, "grid10s": true, "ticks1s": true, "ticks5s": true, "rowHeight": 48, "rowGap": 18, "leftMargin": 120, "topMargin": 24, "pxPerSec": 4}, "overlays": {"adjacentOnly": true, "defaultOpacity": 0.8, "shadeAlpha": 0.15, "repeatByCycle": true, "allowCustomIntervals": true}, "packaging": {"includeDocs": true}};
  }
}

function mkDefaultUTCPlan(cfg){
  return (cfg.utcPlan && Array.isArray(cfg.utcPlan.defaults)) ? JSON.parse(JSON.stringify(cfg.utcPlan.defaults)) : [{to:'S1',at:0},{to:'S2',at:30}];
}

function mkJunction(id, cfg){
  const nStages = Math.max(cfg.stageCount.min, cfg.stageCount.default);
  const stages = []; const minG = cfg.stage.minGreen.default;
  for(let i=0;i<nStages;i++){ stages.push({ label: 'S'+(i+1), minGreenSec: minG }); }
  const N = nStages; const ig = [];
  for(let r=0;r<N;r++){ const row=[]; for(let c=0;c<N;c++){ row.push(r===c ? cfg.intergreen.diagonalLockedValue : cfg.intergreen.defaults.offDiagonal); } ig.push(row); }
  return { id, name:'Junction '+id, doubleCycle:false, utcPlan: mkDefaultUTCPlan(cfg), stages, intergreen: ig, travelPrev: cfg.journeyTime.default, travelNext: cfg.journeyTime.default };
}

function buildState(cfg){
  const count = Math.max(cfg.junctionCount.min, Math.min(cfg.junctionCount.max, cfg.junctionCount.default));
  const ids = ['A','B','C','D','E'].slice(0,count);
  const juncs = ids.map(id=>mkJunction(id, cfg));
  return { ...App.state, mainCycle: Math.max(cfg.mainCycleTime.min, Math.min(cfg.mainCycleTime.max, cfg.mainCycleTime.default)), viewCycles: (cfg.plot.viewCycles && cfg.plot.viewCycles.default)||2, junctions: juncs, pxPerSec: cfg.plot.pxPerSec||4 };
}

function effectiveCycle(j){ return j.doubleCycle ? (App.state.mainCycle/2) : App.state.mainCycle; }
function stageIndex(j, label){ const idx = j.stages.findIndex(s=>s.label===label); return (idx>=0? idx : 0); }
function clampInt(v, lo, hi){ v=parseInt(v||0,10); if(isNaN(v)) v=0; return Math.max(lo, Math.min(hi, v)); }

// ---- min-green realised times (from v1.1.6-alpha) ----
function computeRealisedCycle(j){
  const Cj = effectiveCycle(j);
  const plan = (j.utcPlan||[]).slice().sort((a,b)=>a.at-b.at);
  const N = plan.length;
  if(N===0) return {ok:false, err:['UTC plan empty']};
  const toIdx = plan.map(p=>stageIndex(j,p.to));
  for(let i=0;i<N;i++){
    const from = toIdx[i];
    const to = toIdx[(i+1)%N];
    if(j.intergreen[from][to] === -1){
      const a=j.stages[from].label, b=j.stages[to].label;
      return {ok:false, err:[`${j.name}: Stage move not permitted ${a} → ${b}`]};
    }
  }
  const Rq = new Array(N*2);
  for(let i=0;i<N;i++){ Rq[i]=plan[i].at; }
  for(let i=0;i<N;i++){ Rq[i+N]=plan[i].at + Cj; }
  const RC = new Array(N+1).fill(0);
  RC[0] = Rq[0];
  const details = [];
  for(let i=0;i<N;i++){
    const curIdx = toIdx[i%N];
    const prevIdx = toIdx[(i-1+N)%N];
    const nextIdx = toIdx[(i+1)%N];
    const igPrev = Math.max(0, j.intergreen[prevIdx][curIdx]);
    const mgCur = j.stages[curIdx].minGreenSec|0;
    const nextReq = Rq[i+1];
    const nextNextReq = (i+2<=N) ? Rq[i+2] : (Rq[(i+2)%(N)] + Cj);
    const stageStart = RC[i] + igPrev;
    const earliestMG = stageStart + mgCur;
    const realisedNext = Math.max(nextReq, earliestMG);
    if(realisedNext >= nextNextReq){
      const a = j.stages[curIdx].label, b=j.stages[nextIdx].label;
      return {ok:false, err:[`${j.name}: Stage change not achievable ${a} → ${b} before next request at t=${nextNextReq%Cj}s`]};
    }
    RC[i+1] = realisedNext;
    details.push({i, rqCur:Rq[i], rqNext:nextReq, rqNext2:nextNextReq, igPrev, mgCur, stageStart, earliestMG, realisedNext, delay: realisedNext - nextReq, curStage:j.stages[curIdx].label, nextStage:j.stages[nextIdx].label});
  }
  const RCmod = RC.map(t=> t % Cj);
  return {ok:true, Cj, plan, toIdx, RC, RCmod, details};
}
function travelTimeBetween(fromIdx, toIdx){
  const J = App.state.junctions;
  if(fromIdx===toIdx) return 0;
  let t = 0;
  if(toIdx>fromIdx){
    for(let i=fromIdx;i<toIdx;i++) t += (J[i].travelNext||0);
  }else{
    for(let i=fromIdx;i>toIdx;i--) t += (J[i].travelPrev||0);
  }
  return t;
}

function rowY(top, rowH, gap, idx){
  return top + idx*(rowH+gap);
}

function drawArrowMarker(ctx, x, yMid, dir){
  // dir: +1 (down), -1 (up)
  const len = 8, hw = 6; // head width
  ctx.beginPath();
  if(dir>0){
    ctx.moveTo(x, yMid - len);
    ctx.lineTo(x, yMid + len);
    ctx.moveTo(x - hw/2, yMid + len - hw);
    ctx.lineTo(x, yMid + len);
    ctx.lineTo(x + hw/2, yMid + len - hw);
  }else{
    ctx.moveTo(x, yMid + len);
    ctx.lineTo(x, yMid - len);
    ctx.moveTo(x - hw/2, yMid - len + hw);
    ctx.lineTo(x, yMid - len);
    ctx.lineTo(x + hw/2, yMid - len + hw);
  }
  ctx.stroke();
}

function drawArrowMarkerH(ctx, xMid, y){
  // small right-pointing arrow centered at (xMid, y)
  const len = 10;
  ctx.beginPath();
  ctx.moveTo(xMid - len/2, y);
  ctx.lineTo(xMid + len/2, y);
  ctx.stroke();
  // arrow head to the right
  ctx.beginPath();
  ctx.moveTo(xMid + len/2, y);
  ctx.lineTo(xMid + len/2 - 6, y - 4);
  ctx.lineTo(xMid + len/2 - 6, y + 4);
  ctx.closePath();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
}

function drawArrowHeadRight(ctx, x, y){
  // small filled triangle pointing right, with tip at (x,y)
  const size = 7;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - size, y - size*0.6);
  ctx.lineTo(x - size, y + size*0.6);
  ctx.closePath();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
}

function drawArrowLine(ctx, x1, y1, x2, y2){
  // diagonal line from (x1,y1) to (x2,y2) with an arrow head at end
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  const ang = Math.atan2(y2 - y1, x2 - x1);
  const size = 9;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - size*Math.cos(ang - Math.PI/6), y2 - size*Math.sin(ang - Math.PI/6));
  ctx.lineTo(x2 - size*Math.cos(ang + Math.PI/6), y2 - size*Math.sin(ang + Math.PI/6));
  ctx.closePath();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
}

// ---- validation
function validateJunction(j){
  const errs=[];
  j.stages.forEach((s)=>{
    if(!(Number.isInteger(s.minGreenSec) || typeof s.minGreenSec==='number')) errs.push(`${j.name}: Stage ${s.label} minGreen not a number`);
    if(s.minGreenSec < App.initCfg.stage.minGreen.min) errs.push(`${j.name}: Stage ${s.label} minGreen < ${App.initCfg.stage.minGreen.min}`);
  });
  const Cj = effectiveCycle(j);
  if((j.utcPlan||[]).length===0) errs.push(`${j.name}: UTC plan empty`);
  (j.utcPlan||[]).forEach((p,i)=>{
    if(p.at>=Cj) errs.push(`${j.name}: Plan row #${i+1} at=${p.at} ≥ cycle (${Cj})`);
    if(!j.stages.find(s=>s.label===p.to)) errs.push(`${j.name}: Plan row #${i+1} stage '${p.to}' not found`);
  });
  if(errs.length) return errs;
  const rc = computeRealisedCycle(j);
  if(!rc.ok){ errs.push(...rc.err); }
  return errs;
}

function runValidation({silent}={silent:false}){
  if(!silent) log('Validate clicked','info');
  const errs=[];
  const anyDouble = App.state.junctions.some(j=>j.doubleCycle);
  if(anyDouble && (App.state.mainCycle % 2 !== 0)) errs.push(`Main cycle must be even when any junction is double-cycling.`);
  const anyMain = App.state.junctions.some(j=>!j.doubleCycle);
  if(!anyMain) errs.push(`At least one junction must run the main cycle (not double).`);
  App.state.junctions.forEach(j=>errs.push(...validateJunction(j)));
  const ok = errs.length===0;
  if(ok){
    App.state.validOk = true;
    const v=document.getElementById('validateBtn'); if(v) v.classList.remove('dirty');
    const chip=document.getElementById('statusChip'); if(chip) chip.textContent='Validated ✔ — press Plot to render';
    const plot=document.getElementById('plotBtn'); if(plot) plot.disabled=false;
    const x=document.getElementById('transferBtn'); if(x) x.disabled=false;
    if(!silent) log('VALIDATION OK','info');
    const ba=document.getElementById('bootAlert'); if(ba){ ba.classList.remove('show'); ba.textContent=''; }
  }else{
    App.state.validOk = false;
    const chip=document.getElementById('statusChip'); if(chip) chip.textContent='Validation failed — see alerts';
    const plot=document.getElementById('plotBtn'); if(plot) plot.disabled=true;
    const x=document.getElementById('transferBtn'); if(x) x.disabled=true;
    const msg = 'Fix these first:\n - '+errs.join('\n - ');
    if(silent){
      const ba=document.getElementById('bootAlert'); if(ba){ ba.classList.add('show'); ba.textContent = msg; }
      log('BOOT VALIDATION FAIL: '+errs.join(' | '),'warn');
    }else{
      alert(msg);
      log('VALIDATION FAIL: '+errs.join(' | '),'warn');
    }
  }
  return ok;
}

// ---- drawing hidden
function drawHidden(){
  if(!(App.state.validOk && App.state.readyToPlot)){
    log('Draw suppressed (requires Validate OK + Plot)','warn');
    return;
  }

  const scroller = document.getElementById('timelineScroll');
  const C = document.getElementById('hiddenCanvas');
  const ctx = C.getContext('2d');

  const M = App.state.mainCycle;                                 // main cycle seconds (e.g., 60)
  const mult = (App.initCfg.plot && App.initCfg.plot.hiddenWindowMultiplier) || 5;
  const T = M * mult;                                            // total world seconds
  const pps = App.state.pxPerSec || 4;                           // pixels per second

  // Use dynamic vertical layout
  const { top, rowH, gap, totalH } = computeVerticalLayout();

  // Viewport width is the visible width of the scroll container — canvas does NOT grow with zoom
  const viewportPx = measureViewportPx();
  C.width  = viewportPx;                                         // drawing buffer width matches viewport
  const height = totalH;
  C.height = height;

  // Compute visible window [v0, v1] in seconds and clamp
  const viewDurSec = viewportPx / pps;                           // how many seconds fit in the viewport
  setViewStart(App.state.viewStartSec);                          // clamp to [0, T - viewDurSec]
  const v0 = App.state.viewStartSec;                             // left edge time (s)
  const v1 = v0 + viewDurSec;                                    // right edge time (s)

  // Background
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,C.width,C.height);

  // Grid every 10s inside the viewport only
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  const tick0 = Math.floor(v0/10)*10;
  for(let t=tick0; t<=v1; t+=10){
    const x = (t - v0) * pps;
    ctx.beginPath(); ctx.moveTo(x, top-8); ctx.lineTo(x, height-10); ctx.stroke();
    // top labels show offset from the start of the first cycle
    ctx.fillStyle='#000'; ctx.font='10px system-ui'; ctx.textAlign='center'; ctx.textBaseline='alphabetic';
    ctx.fillText(String(Math.round(t - M)), x, top-12);
  }

  // Bottom labels (absolute seconds)
  (function(){
    try{
      const y = height - 6;
      ctx.save();
      ctx.fillStyle = '#000';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
      for(let t=tick0; t<=v1; t+=10){
        const x = (t - v0) * pps; ctx.fillText(String(Math.round(t)), x, y - 3);
      }
      ctx.restore();
    }catch(e){}
  })();

  const greens = ['rgba(60,180,75,0.9)','rgba(90,205,105,0.9)','rgba(120,220,135,0.9)','rgba(150,235,165,0.9)'];

  // Draw rows clipped to viewport [v0, v1]
  App.state.junctions.forEach((j, idx)=>{
    const y0 = top + idx*(rowH+gap);
    ctx.strokeStyle = '#ddd'; ctx.strokeRect(0, y0, viewportPx, rowH);

    const rc = computeRealisedCycle(j);
    if(!rc.ok){ ctx.fillStyle = '#b00020'; ctx.fillText('ERR: '+rc.err.join(' | '), 8, y0+14); return; }

    const Cj = rc.Cj; const N = rc.plan.length; const cycles = Math.ceil(T / Cj);

    for(let k=0;k<cycles;k++){
      const base = k*Cj;
      // Requested change markers
      if(App.initCfg.utcPlan.markRequestsBlue){
        ctx.strokeStyle = '#4aa1ff'; ctx.lineWidth=2;
        for(let i=0;i<N;i++){
          const rqAbs = base + rc.plan[i].at;
          if(rqAbs < v0 || rqAbs > v1) continue;                  // outside viewport
          const x= (rqAbs - v0) * pps; ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+rowH); ctx.stroke();
        }
      }

      for(let i=0;i<N;i++){
        const curIdx = rc.toIdx[i];
        const prevIdx = rc.toIdx[(i-1+N)%N];
        const nextIdx = rc.toIdx[(i+1)%N];

        const igPrev = Math.max(0, j.intergreen[prevIdx][curIdx]);
        const RCi = rc.RC[i];
        const RCn = rc.RC[i+1];

        const segStartAbs = base + (RCi + igPrev);
        const segEndAbs   = base + RCn;
        const s = Math.max(v0, segStartAbs);
        const e = Math.min(v1, segEndAbs);
        if(e > s){
          ctx.fillStyle = greens[curIdx % greens.length];
          ctx.fillRect((s - v0)*pps, y0+6, (e - s)*pps, rowH-12);
          // Stage label centered in the green bar
          const wpx = (e - s) * pps;
          if(wpx >= 28){
            const xMid = ((s + e)/2 - v0) * pps;
            const yMid = y0 + rowH/2;
            const fs = Math.min(14, Math.max(10, Math.floor(rowH * 0.36)));
            ctx.save();
            ctx.font = fs + 'px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // subtle shadow for contrast on green backgrounds
            ctx.shadowColor = 'rgba(0,0,0,0.45)';
            ctx.shadowBlur = 3;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(j.stages[curIdx].label, xMid, yMid);
            ctx.restore();
          }
        }

        // queued change delay marker (clipped)
        const nextReqAbs = base + rc.details[i].rqNext;
        const delay = rc.details[i].delay;
        if(App.initCfg.utcPlan.showQueuedChangeMarkers && delay>0){
          const x1s = Math.max(v0, nextReqAbs), x2s = Math.max(v0, Math.min(v1, base + RCn));
          if(x2s > x1s){
            ctx.strokeStyle='rgba(74,161,255,0.7)'; ctx.setLineDash([4,3]);
            const x1=(x1s - v0)*pps, x2=(x2s - v0)*pps; ctx.beginPath(); ctx.moveTo(x1, y0+4); ctx.lineTo(x2, y0+4); ctx.stroke(); ctx.setLineDash([]);
            ctx.fillStyle='rgba(74,161,255,0.9)'; ctx.beginPath(); ctx.moveTo(x2, y0+4); ctx.lineTo(x2-5, y0-4); ctx.lineTo(x2+5, y0-4); ctx.closePath(); ctx.fill();
          }
        }

        // intergreen shading (clipped)
        const igNext = Math.max(0, j.intergreen[curIdx][nextIdx]);
        if(igNext>0){
          const igStartAbs = base + RCn, igEndAbs = igStartAbs + igNext;
          const is = Math.max(v0, igStartAbs), ie = Math.min(v1, igEndAbs);
          if(ie>is){ ctx.fillStyle = 'rgba(150,150,150,0.35)'; ctx.fillRect((is-v0)*pps, y0+6, (ie-is)*pps, rowH-12); }
        }
      }
    }
  });
  // ---- Journey overlays (shaded polygons + direction arrows) ----
  if(Array.isArray(App.state._overlays)){
    App.state._overlays.forEach(ovl=>{
      const fromIdx = ovl.from, toIdx = ovl.to;
      if(fromIdx==null || toIdx==null) return;
      const Jfrom = App.state.junctions[fromIdx];
      const rcFrom = computeRealisedCycle(Jfrom);
      if(!rcFrom.ok) return;
      const travel = travelTimeBetween(fromIdx, toIdx);

      const yFrom = rowY(top, rowH, gap, fromIdx);
      const yTo   = rowY(top, rowH, gap, toIdx);
      const yFromTop = yFrom+6, yFromBot = yFrom+rowH-6;
      const yToTop   = yTo+6,   yToBot   = yTo+rowH-6;
      const yMidFrom = (yFromTop + yFromBot)/2;
      const yMidTo   = (yToTop + yToBot)/2;
      const dir = (toIdx>fromIdx) ? +1 : (toIdx<fromIdx ? -1 : 0);

      const Cj = rcFrom.Cj;
      // Determine which cycles to evaluate so that either upstream or downstream windows intersect the viewport
      const kMin = Math.floor((v0 - travel)/Cj) - 1;
      const kMax = Math.ceil((v1)/Cj) + 1;

      for(let k=kMin; k<=kMax; k++){
        const base = k*Cj;
        
        for(let i=0;i<rcFrom.details.length;i++){
          if(ovl.mode === 'time' && i > 0) continue; // time-based: single window per cycle
  const d = rcFrom.details[i];
  let tStartAbs, tEndAbs;
  if(ovl.mode === 'time'){
    tStartAbs = base + (ovl.start||0);
    tEndAbs   = base + Math.max(ovl.start||0, ovl.end||0);
  }else{ // stage-based (default)
    if(ovl.stage && d.curStage !== ovl.stage) continue;
    tStartAbs = base + d.stageStart;      // at(s) + preceding intergreen
    tEndAbs   = base + rcFrom.RC[i+1];    // max(next request, start + minGreen)
  }
        
        
        
        
        
          if(!(tEndAbs > tStartAbs)) continue;

          // Downstream arrival window = upstream window shifted by travel time
          const aStart = tStartAbs + travel;
          const aEnd   = tEndAbs + travel;

          // Cull if completely out of viewport
          if(aStart > v1+5 || tEndAbs < v0-5) continue;

          const xS  = (tStartAbs - v0) * pps;
          const xE  = (tEndAbs   - v0) * pps;
          const xAS = (aStart    - v0) * pps;
          const xAE = (aEnd      - v0) * pps;

          // Decide line heights based on direction
          const yFromLine = (toIdx>fromIdx) ? yFromBot : yFromTop;  // base for downward, top for upward
          const yToLine   = (toIdx>fromIdx) ? yToTop   : yToBot;    // top for downward, bottom for upward

          ctx.save();
          // Shaded polygon connecting the chosen edges of upstream and downstream windows
          ctx.globalAlpha = Math.max(0.05, Math.min(0.95, ovl.alpha || App.initCfg.overlays.shadeAlpha || 0.3));
          ctx.fillStyle = ovl.color || 'rgba(255,165,0,0.25)';
          ctx.beginPath();
          ctx.moveTo(xS,  yFromLine);
          ctx.lineTo(xAS, yToLine);
          ctx.lineTo(xAE, yToLine);
          ctx.lineTo(xE,  yFromLine);
          ctx.closePath();
          ctx.fill();

          // Dashed horizontal windows drawn on those edges
          ctx.globalAlpha = 1;
          ctx.strokeStyle = ovl.color || '#ffa500';
          ctx.lineWidth = 2;
          ctx.setLineDash([6,4]);
          // Upstream release window (horizontal)
          ctx.beginPath(); ctx.moveTo(xS,  yFromLine); ctx.lineTo(xE,  yFromLine); ctx.stroke();
          // Downstream arrival window (horizontal)
          ctx.beginPath(); ctx.moveTo(xAS, yToLine);   ctx.lineTo(xAE, yToLine);   ctx.stroke();
          ctx.setLineDash([]);

          // choose upstream/downstream edges nearest in time to tighten the diagonal endpoints
          const aMid = (aStart + aEnd) / 2;
          const tMid = (tStartAbs + tEndAbs) / 2;
          const upEdgeT   = (Math.abs(tStartAbs - aMid) <= Math.abs(tEndAbs - aMid)) ? tStartAbs : tEndAbs;
          const downEdgeT = (Math.abs(aStart   - tMid) <= Math.abs(aEnd    - tMid)) ? aStart   : aEnd;
          const xUpEdge   = (upEdgeT   - v0) * pps;
          const xDownEdge = (downEdgeT - v0) * pps;

          // Timeline arrows at the right ends of the windows (always forward in time)
          drawArrowHeadRight(ctx, xE,  yFromLine);
          drawArrowHeadRight(ctx, xAE, yToLine);



          // (Label removed)
          ctx.restore();
        }
      }
    });
  }
  const info = document.getElementById('info');
  if(info) info.textContent = `View ${viewDurSec.toFixed(1)}s @ ${pps}px/s · t=[${v0.toFixed(1)}, ${v1.toFixed(1)}] · canvas ${C.width}×${C.height}`;
  log('Hidden canvas redrawn (viewport-fixed)','info');
}

function drawLabels(){
  const label = document.getElementById('labelCanvas');
  const scroller = document.getElementById('timelineScroll');
  if(!label || !scroller) return;
  const lctx = label.getContext('2d');
  const labelW = App.initCfg.plot.leftMargin || 120;
  const { top, rowH, gap, totalH } = computeVerticalLayout();
  const height = totalH;
  // size label canvas to full content height
  label.width = labelW;
  label.height = height;
  // background
  lctx.fillStyle = '#fff';
  lctx.fillRect(0,0,label.width,label.height);
  lctx.fillStyle = '#111';
  lctx.font = '12px system-ui';
  App.state.junctions.forEach((j, idx)=>{
    const y0 = top + idx*(rowH+gap);
    lctx.fillText(j.name, 12, y0 + rowH*0.6);
  });
}


// ---- UI rendering (same as v1.1.6) ----
function renderUTCEditor(j){
  let rows=''; (j.utcPlan||[]).forEach((r,i)=>{
    rows += `<tr>
      <td><select data-t="planTo" data-id="${j.id}" data-idx="${i}">
        ${j.stages.map(s=>`<option value="${s.label}" ${r.to===s.label?'selected':''}>${s.label}</option>`).join('')}
      </select></td>
      <td><input type="number" min="0" step="1" value="${r.at}" data-t="planAt" data-id="${j.id}" data-idx="${i}"></td>
      <td><button data-t="planDel" data-id="${j.id}" data-idx="${i}">Delete</button></td>
    </tr>`;
  });
  return `<h4>UTC Plan</h4>
  <table class="grid"><thead><tr><th>To stage</th><th>At (s)</th><th></th></tr></thead><tbody>${rows}</tbody></table>
  <button data-t="planAdd" data-id="${j.id}">Add change</button>`;
}

function renderJunctionPanel(j){
  const cfg = App.initCfg; const N=j.stages.length;
  let rows = '';
  for(let i=0;i<N;i++){
    rows += `<tr>
      <td><input data-t="stageLabel" data-id="${j.id}" data-idx="${i}" value="${j.stages[i].label}"></td>
      <td><input type="number" min="${cfg.stage.minGreen.min}" value="${j.stages[i].minGreenSec}" data-t="minGreen" data-id="${j.id}" data-idx="${i}"></td>
    </tr>`;
  }
  let ig = '<table class="grid"><thead><tr><th>From \\ To</th>';
  for(let c=0;c<N;c++){ ig += `<th>${j.stages[c].label}</th>`; }
  ig += '</tr></thead><tbody>';
  for(let r=0;r<N;r++){
    ig += `<tr><th>${j.stages[r].label}</th>`;
    for(let c=0;c<N;c++){
      if(r===c){ ig += `<td><input value="${cfg.intergreen.diagonalLockedValue}" disabled></td>`; }
      else{ ig += `<td><input type="number" step="1" min="-1" max="${cfg.intergreen.domain.max}" value="${j.intergreen[r][c]}" data-t="ig" data-id="${j.id}" data-r="${r}" data-c="${c}"></td>`; }
    }
    ig += '</tr>';
  }
  ig += '</tbody></table>';

  return `
    <div class="row">
      <label>Double cycle <input type="checkbox" data-t="double" data-id="${j.id}" ${j.doubleCycle?'checked':''}></label>
      <label>To previous (↑)<input type="number" min="${App.initCfg.journeyTime.min}" max="${App.initCfg.journeyTime.max}" value="${j.travelPrev}" data-t="travelPrev" data-id="${j.id}"></label>
      <label>To next (↓)<input type="number" min="${App.initCfg.journeyTime.min}" max="${App.initCfg.journeyTime.max}" value="${j.travelNext}" data-t="travelNext" data-id="${j.id}"></label>
      <label>Stage count<input type="number" min="${App.initCfg.stageCount.min}" max="8" value="${j.stages.length}" data-t="stageCount" data-id="${j.id}"></label>
    </div>
    <h4>Stages</h4>
    <table class="grid">
      <thead><tr><th>Label</th><th>Min green (s)</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
    <h4>Intergreen matrix (leading intergreen; -1 = not permitted)</h4>
    ${ig}
    ${renderUTCEditor(j)}
  `;
}

function rebuildTabs(){
  const tabs = document.getElementById('jtabs'); const panels = document.getElementById('tabpanels'); tabs.innerHTML=''; panels.innerHTML='';
  App.state.junctions.forEach((j, idx)=>{
    const t=document.createElement('button'); t.className='tab'+(idx===0?' active':''); t.textContent=j.name; t.dataset.id=j.id;
    t.addEventListener('click', ()=>{ document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active')); t.classList.add('active');
      document.querySelectorAll('.tabpanel').forEach(p=>p.classList.remove('active')); document.getElementById('tp_'+j.id).classList.add('active'); });
    tabs.appendChild(t);
    const tp=document.createElement('div'); tp.id='tp_'+j.id; tp.className='tabpanel'+(idx===0?' active':'');
    tp.innerHTML = renderJunctionPanel(j);
    panels.appendChild(tp);
  });
  wirePanelInputs();
  log('Junction tabs rendered','info');
}

function wirePanelInputs(){
  document.querySelectorAll('[data-t]').forEach(inp=>{
    const t=inp.getAttribute('data-t');
    if(t==='planAdd' || t==='planDel'){ inp.addEventListener('click', (e)=>{ onUTCEdit(e); setDirty(); }); }
    else{
      inp.addEventListener('change', (e)=>{ onPanelChange(e); setDirty(); });
      inp.addEventListener('blur',   (e)=>{ onPanelChange(e); setDirty(); });
    }
  });
}
function findJ(id){ return App.state.junctions.find(x=>x.id===id); }

function onUTCEdit(e){
  const t = e.target.getAttribute('data-t'); const id=e.target.getAttribute('data-id'); const j=findJ(id); if(!j) return;
  if(t==='planAdd'){ j.utcPlan.push({to:(j.stages[0]&&j.stages[0].label)||'S1', at:0}); rebuildTabs(); return; }
  if(t==='planDel'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan.splice(idx,1); rebuildTabs(); return; }
}

function onPanelChange(e){
  const t=e.target.getAttribute('data-t'); const id=e.target.getAttribute('data-id');
  const j=findJ(id); if(!j) return;
  if(t==='double'){ j.doubleCycle = e.target.checked; }
  if(t==='travelPrev'){ j.travelPrev = clampInt(e.target.value, App.initCfg.journeyTime.min, App.initCfg.journeyTime.max); e.target.value=j.travelPrev; }
  if(t==='travelNext'){ j.travelNext = clampInt(e.target.value, App.initCfg.journeyTime.min, App.initCfg.journeyTime.max); e.target.value=j.travelNext; }
  if(t==='stageCount'){ const n = Math.max(App.initCfg.stageCount.min, Math.min(8, parseInt(e.target.value||2,10))); resizeStages(j, n); rebuildTabs(); }
  if(t==='stageLabel'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].label = e.target.value|| ('S'+(idx+1)); rebuildTabs(); }
  if(t==='minGreen'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].minGreenSec = Math.max(App.initCfg.stage.minGreen.min, parseInt(e.target.value||App.initCfg.stage.minGreen.default,10)); e.target.value=j.stages[idx].minGreenSec; }
  if(t==='ig'){ const r=parseInt(e.target.getAttribute('data-r'),10), c=parseInt(e.target.getAttribute('data-c'),10);
    let v = parseInt(e.target.value||0,10); if(v!==-1) v = Math.max(App.initCfg.intergreen.domain.min, Math.min(App.initCfg.intergreen.domain.max, v));
    j.intergreen[r][c] = v; e.target.value = v; }
  if(t==='planTo'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan[idx].to = e.target.value; }
  if(t==='planAt'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan[idx].at = Math.max(0, parseInt(e.target.value||0,10)); }
}

function resizeStages(j, n){
  const minG = App.initCfg.stage.minGreen.default;
  while(j.stages.length < n){ j.stages.push({label:'S'+(j.stages.length+1), minGreenSec:minG}); }
  while(j.stages.length > n){ j.stages.pop(); }
  const N = j.stages.length;
  const igNew = [];
  for(let r=0;r<N;r++){ const row=[]; for(let c=0;c<N;c++){ row.push(r===c ? App.initCfg.intergreen.diagonalLockedValue : (j.intergreen[r] && typeof j.intergreen[r][c]==='number' ? j.intergreen[r][c] : App.initCfg.intergreen.defaults.offDiagonal)); } igNew.push(row); }
  j.intergreen = igNew;
  j.utcPlan.forEach(p=>{ if(!j.stages.find(s=>s.label===p.to)) p.to = j.stages[0].label; });
}

// ---- boot
async function boot(){
  App.initCfg = await loadBundledInit();
  const dbgPanel = document.getElementById('debugPanel');
  const wantDebugOnLoad = !!(App.initCfg.ui && App.initCfg.ui.debug && App.initCfg.ui.debug.enabled && App.initCfg.ui.debug.dock && App.initCfg.ui.debug.dock.showOnLoad);
  if(wantDebugOnLoad && window.__showPanel){ window.__showPanel('debug'); }
  document.getElementById('dbgClear').addEventListener('click', ()=>{ document.getElementById('log').textContent=''; });

  App.state = buildState(App.initCfg);
  // Pre-plot default: choose px/s so [mainCycle, mainCycle*viewCycles] fills the viewport
  (function(){
    const vp = measureViewportPx();
    const Cj = App.state.mainCycle;
    const N  = App.state.viewCycles || 2;
    if(vp > 0 && Cj){
      App.state.pxPerSec = Math.max(1, vp / (N*Cj));
      setViewStart(Cj);
      const zoom = document.getElementById('zoom');
      if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
    }
  })();
  document.getElementById('mainCycle').value = App.state.mainCycle;
  document.getElementById('jCount').value = App.state.junctions.length;
  document.getElementById('viewCycles').value = String(App.state.viewCycles);
  rebuildTabs();
  setDirty(); // force validation before any plot
  log('App booted — smoke-check…','info');

  // Boot-time smoke-check (silent)
  runValidation({silent:true});

  document.getElementById('mainCycle').addEventListener('change', (e)=>{
    const v=parseInt(e.target.value||60,10);
    const clamped=Math.max(App.initCfg.mainCycleTime.min, Math.min(App.initCfg.mainCycleTime.max, v));
    App.state.mainCycle=clamped; e.target.value=clamped; setDirty();
    // Pre-plot: choose px/s so [C, C*N] fits the viewport
    if(!App.state.readyToPlot){
      const vp = measureViewportPx();
      const N = App.state.viewCycles || 2;
      App.state.pxPerSec = Math.max(1, vp / (N*App.state.mainCycle));
      setViewStart(App.state.mainCycle);
      const zoom = document.getElementById('zoom');
      if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
    }
  });
  document.getElementById('jCount').addEventListener('change', (e)=>{
    const v=parseInt(e.target.value||3,10);
    const c=Math.max(App.initCfg.junctionCount.min, Math.min(App.initCfg.junctionCount.max, v));
    const cur=App.state.junctions.length; const ids=['A','B','C','D','E'];
    if(c>cur){ for(let i=cur;i<c;i++) App.state.junctions.push(mkJunction(ids[i], App.initCfg)); }
    else if(c<cur){ App.state.junctions.splice(c); }
    e.target.value=c; rebuildTabs(); setDirty();
  });
  document.getElementById('viewCycles').addEventListener('change', (e)=>{
    App.state.viewCycles=parseInt(e.target.value||2,10);
    setDirty();
    // Pre-plot: recompute to keep [C, C*N]
    if(!App.state.readyToPlot){
      const vp = measureViewportPx();
      const Cj = App.state.mainCycle;
      const N  = App.state.viewCycles || 2;
      if(vp>0 && Cj){
        App.state.pxPerSec = Math.max(1, vp / (N*Cj));
        setViewStart(Cj);
        const zoom = document.getElementById('zoom');
        if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
      }
    }
  });

  document.getElementById('validateBtn').addEventListener('click', ()=>{ runValidation({silent:false}); });
  document.getElementById('plotBtn').addEventListener('click', ()=>{
if(!App.state.validOk){ alert('Please Validate first.'); return; }
App.state.readyToPlot = true;
const p=document.getElementById('plotBtn'); if(p) p.classList.remove('dirty');
const chip=document.getElementById('statusChip'); if(chip) chip.textContent='Plotted ✓';
log('Plot clicked — drawing (viewport-fixed)','info');

// Initial default view: choose px/s so [C, C*N] fills viewport exactly
const Cj = App.state.mainCycle; const N = App.state.viewCycles || 2;
const viewportPx = measureViewportPx();
App.state.pxPerSec = Math.max(1, viewportPx / Math.max(1, N*Cj));
const zoom = document.getElementById('zoom');
if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
setViewStart(Cj);

drawHidden();
drawLabels();
  });
  // (transferBtn block removed)

  const zoom = document.getElementById('zoom');
  if(zoom){
    const zmin = 1, zmax = 12; // slider range
    // initialise slider position from pxPerSec -> slider value (invert mapping)
    zoom.value = String(zmax - (App.state.pxPerSec - zmin));
    zoom.addEventListener('input', ()=>{
      const C = document.getElementById('hiddenCanvas');
      const oldPps = App.state.pxPerSec||4;
      const centerSec = App.state.viewStartSec + (C.width/oldPps)/2;
      const val = Math.max(zmin, Math.min(zmax, parseInt(zoom.value,10) || zmin));
      App.state.pxPerSec = Math.max(1, (zmax - val) + zmin); // LEFT = bigger spacing
      const newViewDur = C.width / App.state.pxPerSec;
      setViewStart(centerSec - newViewDur/2);
      drawHidden();
      drawLabels();
    });
  }
  const fit = document.getElementById('fitBtn');
  if(fit){ fit.addEventListener('click', ()=>{
    const Cj = App.state.mainCycle; const N = App.state.viewCycles || 2;
    const viewportPx = measureViewportPx();
    const pps = Math.max(1, Math.floor(viewportPx / Math.max(1, N*Cj)));
    App.state.pxPerSec = pps;
    if(zoom){ const zmin=1,zmax=12; zoom.value = String(zmax - (App.state.pxPerSec - zmin)); }
    const centerSec = 1*Cj + (N*Cj)/2; // focus cycles 1..N
    setViewStart(centerSec - (viewportPx/pps)/2);
    drawHidden(); drawLabels();
  }); }
  // Add scroll event to timelineScroll to keep labels synced
  const scroller = document.getElementById('timelineScroll');
  if(scroller){
    scroller.addEventListener('wheel', (e)=>{
      e.preventDefault(); // keep the page still
      const scale = (e.shiftKey ? 0.25 : 1); // Shift for finer pan
      const delta = (Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY) * scale;
      const secDelta = delta / (App.state.pxPerSec||1);
      setViewStart(App.state.viewStartSec + secDelta);
      drawHidden();
    }, {passive:false});
  }

  // --- Overlays modal wiring ---
  (function(){
    const btn = document.getElementById('overlayBtn');
    const modal = document.getElementById('ovlModal');
    const closeBtn = document.getElementById('ovlCloseBtn');
    const cancelBtn = document.getElementById('ovlCancel');
    const saveBtn = document.getElementById('ovlSave');
    const selFrom = document.getElementById('ovlFrom');
    const selTo   = document.getElementById('ovlTo');
const modeSel = document.getElementById('ovlMode');
const s = document.getElementById('ovlStart');
const e = document.getElementById('ovlEnd');

    const col = document.getElementById('ovlColor');
    const a = document.getElementById('ovlAlpha');
    const selStage = document.getElementById('ovlStage');
    const stageGroup = document.getElementById('stageGroup');
const timeGroup  = document.getElementById('timeGroup');
function updateModeVisibility(){
  const m = (modeSel && modeSel.value) || 'stage';
  if(stageGroup) stageGroup.style.display = (m==='stage') ? '' : 'none';
  if(timeGroup)  timeGroup.style.display  = (m==='time')  ? '' : 'none';
}               
    function populateJunctions(){
      const juncs = (App.state.junctions||[]);
      function fillJ(sel){
        if(!sel) return; sel.innerHTML='';
        juncs.forEach((j,idx)=>{
          const opt=document.createElement('option');
          opt.value=String(idx);
          opt.textContent=j.name; // show junction name
          sel.appendChild(opt);
        });
      }
      fillJ(selFrom); fillJ(selTo);
      if(selTo && selFrom && selTo.options.length>1){
        selTo.selectedIndex = Math.min(selFrom.selectedIndex+1, selTo.options.length-1);
      }
      populateStages();
      updateModeVisibility();
    }

  function populateStages(){
   if(!selStage) return;
   selStage.innerHTML='';
   const fromIdx = parseInt(selFrom && selFrom.value || '0',10) || 0;
   const J = (App.state.junctions||[])[fromIdx];
   const stages = (J && Array.isArray(J.stages)) ? J.stages : [];
   stages.forEach(st=>{
     const opt=document.createElement('option');
     opt.value = st.label;       // value is stage label
     opt.textContent = st.label; // display label
      selStage.appendChild(opt);
    }); 
  }

  function openModal(){
    populateJunctions();
    renderOverlayList();
    modal.classList.add('show');
    modal.setAttribute('aria-hidden','false');
  }
    function closeModal(){ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }

    if(btn){ btn.addEventListener('click', openModal); }
    if(closeBtn){ closeBtn.addEventListener('click', closeModal); }
    if(cancelBtn){ cancelBtn.addEventListener('click', closeModal); }
    if(modal){ modal.addEventListener('click', (ev)=>{ if(ev.target===modal) closeModal(); }); }
    document.addEventListener('keydown', (ev)=>{ if(ev.key==='Escape' && modal.classList.contains('show')) closeModal(); });
    if(modeSel){ modeSel.addEventListener('change', updateModeVisibility); }



    // Handle delete / clear-all in the overlay list
const listBox = document.getElementById('ovlList');
if(listBox){
  listBox.addEventListener('click', (ev)=>{
    const delIdx = ev.target && ev.target.getAttribute && ev.target.getAttribute('data-del-ovl');
    if(delIdx!=null){
      const i = parseInt(delIdx,10);
      if(Array.isArray(App.state._overlays) && i>=0 && i < App.state._overlays.length){
        App.state._overlays.splice(i,1);
        renderOverlayList();
        if(App.state.readyToPlot && App.state.validOk){ drawHidden(); }
      }
    }
    if(ev.target && ev.target.hasAttribute && ev.target.hasAttribute('data-clear-all')){
      if(Array.isArray(App.state._overlays) && App.state._overlays.length){
        App.state._overlays.length = 0;
        renderOverlayList();
        if(App.state.readyToPlot && App.state.validOk){ drawHidden(); }
      }
    }
  });
}


if(selFrom){ selFrom.addEventListener('change', populateStages); }

    if(saveBtn){
      saveBtn.addEventListener('click', ()=>{
        // Lazy in-memory store for now
        App.state._overlays = App.state._overlays || [];
        
        const mode = (modeSel && modeSel.value) || 'stage';
const base = {
  from: parseInt(selFrom.value||'0',10),
  to:   parseInt(selTo.value||'0',10),
  mode,
  color: col.value||'#ffa500',
  alpha: Math.max(0, Math.min(1, parseFloat(a.value||'0.3')||0.3))
};
if(mode==='stage'){
  base.stage = (selStage && selStage.value) || null;
}else{ // time-based
  base.start = Math.max(0, parseFloat(s && s.value || '0')||0);
  base.end   = Math.max(base.start, parseFloat(e && e.value || '0')||0);
}
App.state._overlays.push(base);

renderOverlayList();
if(App.state.readyToPlot && App.state.validOk){ drawHidden(); }

        log('Overlay saved (temp): '+JSON.stringify(App.state._overlays[App.state._overlays.length-1]), 'info');
        closeModal();
      });
    }

    // Insert renderOverlayList at IIFE scope after populateStages
    function renderOverlayList(){
      const box = document.getElementById('ovlList');
      if(!box) return;
      const list = Array.isArray(App.state._overlays) ? App.state._overlays : [];
      if(list.length === 0){
        box.innerHTML = '<div class="muted" style="font-size:12px">No overlays yet.</div>';
        return;
      }
      const juncs = App.state.junctions||[];
const rows = list.map((o,idx)=>{
  const jf = juncs[o.from] ? juncs[o.from].name : ('J'+o.from);
  const jt = juncs[o.to]   ? juncs[o.to].name   : ('J'+o.to);
  const mode = o.mode || 'stage';
  const detail = (mode==='stage') ? (o.stage || '—') : `${o.start||0}–${o.end||0}s`;
  const swatch = `<span style="display:inline-block;width:10px;height:10px;background:${o.color||'#ffa500'};border:1px solid #ccc;border-radius:2px;vertical-align:middle;margin-right:6px"></span>`;
  return `<tr>
    <td style="text-align:left">${swatch}${jf} → ${jt}</td>
    <td>${mode}</td>
    <td>${detail}</td>
    <td><button data-del-ovl="${idx}">Delete</button></td>
  </tr>`;
}).join('');
box.innerHTML = `<table class="grid"><thead><tr><th>Route</th><th>Mode</th><th>Stage / Time</th><th></th></tr></thead><tbody>${rows}</tbody></table>









        <div style="margin-top:8px;display:flex;justify-content:flex-end"><button data-clear-all>Clear all</button></div>`;
    }
  })();
}
boot();
// === Drag-to-pan (pointer drag on the timeline) ===
(function addDragPan(){
  const area = document.getElementById('timelineScroll');
  if(!area) return;
  let dragging = false, startX = 0, startV0 = 0;

  area.addEventListener('pointerdown', (e)=>{
    dragging = true;
    startX = e.clientX;
    startV0 = App.state.viewStartSec;
    try{ area.setPointerCapture(e.pointerId); }catch(_){/* noop */}
  });
  area.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx = e.clientX - startX;
    const secDelta = -dx / (App.state.pxPerSec || 1);
    setViewStart(startV0 + secDelta);
    drawHidden();
  });
  ['pointerup','pointercancel','pointerleave'].forEach(type=>{
    area.addEventListener(type, ()=>{
      dragging = false;
    });
  });
})();

// === Arrow keys to pan (Shift for fine pan) ===
(function addKeyPan(){
  function stepSec(){
    const C = document.getElementById('hiddenCanvas');
    const px = (C && C.width) || 600;
    return Math.max(1, Math.round((px / (App.state.pxPerSec||1)) * 0.1));
  }
  document.addEventListener('keydown', (e)=>{
    if(document.activeElement && ['INPUT','SELECT','TEXTAREA'].includes(document.activeElement.tagName)) return;
    if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
      e.preventDefault();
      const fine = e.shiftKey ? 0.25 : 1;
      const deltaSec = stepSec() * (e.key==='ArrowLeft' ? -1 : 1) * fine;
      setViewStart(App.state.viewStartSec + deltaSec);
      drawHidden();
    }
  });
})();

// === Redraw on window resize (keep viewport width in sync) ===
(function addResizeRedraw(){
  let t=null;
  window.addEventListener('resize', ()=>{
    clearTimeout(t);
    t = setTimeout(()=>{
      const vp = measureViewportPx();
      if(App.state.readyToPlot && App.state.validOk){
        drawHidden();
        drawLabels();
      }else{
        // Before first plot: choose px/s so [C, C*N] fits the viewport
        const Cj = App.state.mainCycle; const N = App.state.viewCycles || 2;
        if(Cj){
          const vp2 = measureViewportPx();
          if(vp2>0){
            App.state.pxPerSec = Math.max(1, vp2 / Math.max(1, N*Cj));
            setViewStart(Cj);
            const zoom = document.getElementById('zoom');
            if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
          }
        }
      }
    }, 120);
  });
})();

// === Pinch/Trackpad zoom with pointer anchor ===
(function addWheelPinchZoom(){
  const area = document.getElementById('timelineScroll');
  if(!area) return;
  const zoomSlider = document.getElementById('zoom');
  const zmin = 1, zmax = 12;

  area.addEventListener('wheel', (e)=>{
    if(!e.ctrlKey) return; // only treat ctrl+wheel as zoom (trackpad pinch)
    e.preventDefault();
    const rect = area.getBoundingClientRect();
    const oldPps = App.state.pxPerSec || 4;
    const x = e.clientX - rect.left;              // px from left edge in viewport
    const anchorSec = App.state.viewStartSec + (x / oldPps);

    // deltaY > 0 => zoom out; < 0 => zoom in. Pick a gentle factor.
    const factor = Math.exp(-e.deltaY * 0.0015);
    let newPps = oldPps * factor;
    newPps = Math.max(1, Math.min(200, newPps)); // clamp sane range
    App.state.pxPerSec = newPps;

    // Keep the same timeline second under the pointer after zoom
    const newV0 = anchorSec - (x / newPps);
    setViewStart(newV0);

    // Sync slider (inverted mapping)
    if(zoomSlider){ zoomSlider.value = String(zmax - (Math.round(App.state.pxPerSec) - zmin)); }

    drawHidden();
    drawLabels();
  }, {passive:false});
})();

// === Touch pinch-to-zoom (two fingers) with midpoint anchor ===
(function addTouchPinchZoom(){
  const area = document.getElementById('timelineScroll');
  if(!area) return;
  const zoomSlider = document.getElementById('zoom');
  const zmin = 1, zmax = 12;
  let tracking = false;
  let startDist = 0;
  let startPps = 0;
  let anchorX = 0; // viewport px from left
  let anchorSec = 0;

  function getTouches(e){ return e.touches ? Array.from(e.touches) : []; }
  function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
  function mid(a,b){ return { x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2 }; }

  area.addEventListener('touchstart', (e)=>{
    const ts = getTouches(e);
    if(ts.length===2){
      const rect = area.getBoundingClientRect();
      startDist = dist(ts[0], ts[1]);
      startPps = App.state.pxPerSec || 4;
      const m = mid(ts[0], ts[1]);
      anchorX = m.x - rect.left;
      anchorSec = App.state.viewStartSec + (anchorX / startPps);
      tracking = true;
      e.preventDefault();
    }
  }, {passive:false});

  area.addEventListener('touchmove', (e)=>{
    if(!tracking) return;
    const ts = getTouches(e);
    if(ts.length!==2){ tracking=false; return; }
    const d = dist(ts[0], ts[1]);
    if(startDist <= 0) return;
    const factor = d / startDist; // >1 zoom in, <1 zoom out
    let newPps = startPps * factor;
    newPps = Math.max(1, Math.min(200, newPps));
    App.state.pxPerSec = newPps;

    const newV0 = anchorSec - (anchorX / newPps);
    setViewStart(newV0);

    if(zoomSlider){ zoomSlider.value = String(zmax - (Math.round(App.state.pxPerSec) - zmin)); }
    drawHidden();
    drawLabels();
    e.preventDefault();
  }, {passive:false});

  area.addEventListener('touchend', ()=>{ tracking=false; }, {passive:true});
  area.addEventListener('touchcancel', ()=>{ tracking=false; }, {passive:true});
})();

// === iOS Safari gesture events fallback (gesturestart/gesturechange/gestureend) ===
(function addWebkitGestureZoom(){
  const area = document.getElementById('timelineScroll');
  if(!area) return;
  const zoomSlider = document.getElementById('zoom');
  const zmin = 1, zmax = 12;
  let startPps = 0;
  let anchorX = 0; // px from left in the viewport
  let anchorSec = 0;

  function clampPps(v){ return Math.max(1, Math.min(200, v)); }

  area.addEventListener('gesturestart', (e)=>{
    // Prevent page zoom and initialize anchor under gesture center
    e.preventDefault();
    const rect = area.getBoundingClientRect();
    startPps = App.state.pxPerSec || 4;
    // Safari provides clientX/clientY as the gesture center
    anchorX = (typeof e.clientX === 'number' ? (e.clientX - rect.left) : (rect.width/2));
    anchorSec = App.state.viewStartSec + (anchorX / startPps);
  }, {passive:false});

  area.addEventListener('gesturechange', (e)=>{
    e.preventDefault();
    const newPps = clampPps(startPps * (e.scale || 1));
    App.state.pxPerSec = newPps;
    const newV0 = anchorSec - (anchorX / newPps);
    setViewStart(newV0);
    if(zoomSlider){ zoomSlider.value = String(zmax - (Math.round(App.state.pxPerSec) - zmin)); }
    drawHidden();
    drawLabels();
  }, {passive:false});

  area.addEventListener('gestureend', (e)=>{
    // no-op; keep final zoom
    if(e && e.preventDefault) e.preventDefault();
  }, {passive:false});
})();
</script>

<script>
// Master Data / Plot / Debug tab handling..
(function(){
function el(id){ return document.getElementById(id); }

function setActive(btnId){
  ['tabDataBtn','tabPlotBtn','tabDebugBtn'].forEach(id=>{
    const btn = el(id);
    if(btn){ btn.classList.toggle('active', id===btnId); }
  });
}

function showPanel(which){
  // hide all
  const dataCard = el('bootAlert') && el('bootAlert').parentElement;
  if(dataCard) dataCard.style.display='none';
  const plot = el('plotPanel'); if(plot){ plot.style.display='none'; plot.setAttribute('aria-hidden','true'); }
  const dbg  = el('debugPanel'); if(dbg){ dbg.style.display='none'; dbg.setAttribute('aria-hidden','true'); }

  // show requested
  if(which==='data'){
    setActive('tabDataBtn');
    if(dataCard) dataCard.style.display='';
  }else if(which==='plot'){
    setActive('tabPlotBtn');
    if(plot){ plot.style.display=''; plot.setAttribute('aria-hidden','false'); }
    // After becoming visible, measure and redraw on next frame to avoid blurry oversize canvas
    requestAnimationFrame(()=>{
      if(typeof drawLabels === 'function') drawLabels();
      if(typeof drawHidden === 'function' && App.state && App.state.validOk && App.state.readyToPlot){
        drawHidden();
        // One-shot auto-fit on first time Plot becomes visible after plotting
        if(!App.state.didAutoFit){
          const Cj = App.state.mainCycle; const N = App.state.viewCycles || 2;
          const viewportPx = measureViewportPx();
          if(viewportPx > 0 && Cj){
            // choose px/s so [C, C*N] fills the viewport exactly and set left edge at C
            App.state.pxPerSec = Math.max(1, viewportPx / Math.max(1, N*Cj));
            setViewStart(Cj);
            const zoom = document.getElementById('zoom');
            if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
            drawHidden();
            drawLabels();
            App.state.didAutoFit = true;
          }
        }
      }
    });
  }else if(which==='debug'){
    setActive('tabDebugBtn');
    if(dbg){ dbg.style.display=''; dbg.setAttribute('aria-hidden','false'); }
  }
}

// Expose showPanel for boot-time use
window.__showPanel = showPanel;

document.addEventListener('DOMContentLoaded', ()=>{
  el('tabDataBtn')  && el('tabDataBtn').addEventListener('click', ()=> showPanel('data'));
  el('tabPlotBtn')  && el('tabPlotBtn').addEventListener('click', ()=> showPanel('plot'));
  el('tabDebugBtn') && el('tabDebugBtn').addEventListener('click', ()=> showPanel('debug'));
  // initial state
  showPanel('data');
});
})();
</script>

<!-- Overlays modal (temporary) -->
<div id="ovlModal" class="modal-backdrop" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal-card" role="document" aria-labelledby="ovlTitle">
    <header>
      <h3 id="ovlTitle">Add overlay</h3>
      <button id="ovlCloseBtn" aria-label="Close">✕</button>
    </header>
    <div class="body">
      <div class="modal-grid">
        <label>From
          <select id="ovlFrom"></select>
        </label>
        <label>To
          <select id="ovlTo"></select>
        </label>
        <label>Mode
  <select id="ovlMode">
    <option value="stage" selected>Stage-based</option>
    <option value="time">Time-based</option>
  </select>
</label>
<div id="stageGroup">
  <label>Stage (origin)
    <select id="ovlStage"></select>
  </label>
</div>
<div id="timeGroup" style="display:none">
  <label>Start (s)
    <input type="number" id="ovlStart" min="0" step="1" value="0"/>
  </label>
  <label>End (s)
    <input type="number" id="ovlEnd" min="0" step="1" value="10"/>
  </label>
</div>      
        <label>Color
          <input type="color" id="ovlColor" value="#ffa500"/>
        </label>
        <label>Opacity (0–1)
          <input type="number" id="ovlAlpha" min="0" max="1" step="0.05" value="0.3"/>
        </label>
      </div>
      <hr style="border:none;border-top:1px solid var(--line);margin:10px 0"/>
      <h4 style="margin:0 0 6px 0;font-size:13px">Current overlays</h4>
      <div id="ovlList"></div>
      <p class="muted" style="margin-top:8px;font-size:12px">
        This is a temporary overlay editor. Saving stores to memory only; drawing integration comes next.
      </p>
    </div>
    <footer>
      <button id="ovlCancel">Cancel</button>
      <button id="ovlSave">Save overlay</button>
    </footer>
  </div>
</div>

  
    
      
      
    
     
</body>
</html>
