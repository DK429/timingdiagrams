<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Signal Plan Checker 2.0.0</title>
<style>
:root{--bg:#ffffff;--card:#f8f9fb;--line:#e8e8e8;--ink:#222;--muted:#666;--accent:#0a66ff;--errbg:#fff4f4;--errbd:#f5c2c7;--errink:#842029;--block-gap:12px;--mincol:4ch;--utcPlan-vshift:2rem;}
*{box-sizing:border-box} html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;height:100%}
header{padding:14px 16px;border-bottom:1px solid var(--line);background:#fafafa}
.header-row{display:flex;align-items:baseline;gap:12px;justify-content:space-between}
h1{font-size:18px;margin:0} small.muted{color:var(--muted)}
/* #fileNameLabel rule is now handled in .infobar-line below */
main{height:calc(100vh - 60px);display:grid;grid-template-rows:auto 1fr;gap:10px;padding:10px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.card{background:var(--card);border:1px solid var(--line);border-radius:10px;padding:10px}
.alert{display:none;margin:8px 0;padding:10px 12px;border:1px solid var(--errbd);background:var(--errbg);color:var(--errink);border-radius:8px}
.alert.show{display:block}
.tabs{display:flex;gap:6px;margin-top:6px;flex-wrap:wrap}
.tabs .push-right{ margin-left:auto }
.tab{padding:8px 10px;border:1px solid var(--line);border-bottom:none;border-radius:8px 8px 0 0;background:#f1f3f6;cursor:pointer}
.tab.active{background:#fff}
.tab[disabled]{opacity:.5;cursor:not-allowed}
#tabDebugBtn{display:none}
.tabpanel{display:none;border:1px solid var(--line);border-radius:0 10px 10px 10px;padding:8px;background:#fff;overflow:auto;min-height:0}
.tabpanel.active{display:block}
.grid{border-collapse:collapse;width:100%} .grid th,.grid td{border:1px solid #eee;padding:6px 8px;font-size:12px;text-align:center} .grid th{background:#f7f7f7}
button{padding:8px 10px;border:1px solid #d0d0d0;border-radius:8px;background:#f7f7f7;cursor:pointer;transition:box-shadow .15s,border-color .15s}
button.dirty{border-color:var(--accent); box-shadow: 0 0 0 3px rgba(10,102,255,.15)}
button:disabled{opacity:.55; cursor:not-allowed}
label{display:flex;flex-direction:column;font-size:12px;gap:4px}
input[type=number], select{padding:6px 8px;border:1px solid #d6d6d6;border-radius:6px;min-width:70px}
.badge{padding:2px 6px;border-radius:6px;background:#eef1ff;border:1px solid #dbe1ff;font-size:12px}
#plotPanel{display:grid;grid-template-rows:auto 1fr;gap:8px;height:100%}
#plotToolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
#hiddenWrap{border:1px dashed #bbb;border-radius:8px;background:#fff;overflow:hidden;position:relative;height:100%}
.plot-row{display:flex;align-items:stretch}
#timelineScroll{overflow:hidden;flex:1 1 auto;min-width:0;-webkit-overflow-scrolling:touch;overscroll-behavior:contain;touch-action:none}
#labelCanvas{display:block;flex:0 0 120px;width:120px;background:#fff}
#hiddenCanvas{display:block;width:100%;height:auto;image-rendering:crisp-edges}
#visibleWrap{border:1px solid #bbb;border-radius:8px;background:#fff;overflow:auto;position:relative}
#visibleCanvas{display:block;image-rendering:crisp-edges}
#debugPanel
{ max-height:40vh;
  overflow:auto;
  background:#0d1117;
  color:#c9d1d9;
  border:1px solid #30363d;
  border-radius:10px;padding:8px;font-family:ui-monospace,Consolas,Monaco,monospace
}

/* Overlay modal */
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:10000}
.modal-backdrop.show{display:flex}
.modal-card{width:auto;max-width:min(720px,90vw);max-height:80vh;overflow:auto;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
/* Allow modal card to be positioned by JS (for dragging) */
.modal-card{ position:absolute; }
/* Make modal headers show a move cursor while draggable */
.modal-card header{ cursor:move; user-select:none; }
.modal-card header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--line)}
.modal-card .body{padding:12px 14px}
.modal-card footer{display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid var(--line)}
.modal-card h3{margin:0;font-size:16px}
.modal-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.modal-grid label{font-size:12px}
.modal-grid input[type=number], .modal-grid select, .modal-grid input[type=color]{width:auto}
/* Compact modal control sizing */
.modal-grid{ grid-template-columns:max-content max-content; column-gap:16px; row-gap:10px; align-items:end; }
.modal-grid label{ white-space:nowrap; }

/* Number inputs: leave room for spinner controls */
.modal-grid input[type=number]{ width:7ch; min-width:7ch; }

/* Specific fields */
#ovlStart, #ovlEnd, #adjOffset{ width:7ch; }
#ovlAlpha{ width:6ch; }
#adjBoundaries input[type=number]{ width:7ch; }

/* Stage selector a bit wider than numbers */
#ovlStage{ width:10ch; }

/* From/To junction selects: moderate width for names */
#ovlFrom, #ovlTo{ width:18ch; }

/* Main colour input: narrow to match adjacent inputs */
#ovlColor{ width:8ch; }

/* Place Stage or Time group in the second column next to Mode */
#stageGroup, #timeGroup{ grid-column: 2; }

/* Time-based inputs inline: Start then End, aligned to the bottom like other controls */
#timeGroup{ display:flex; gap:12px; align-items:end; }
#timeGroup label{ margin:0; white-space:nowrap; }
/* Normalize iOS Safari colour input (fix deformed oval & rainbow ring) */
.modal-grid input[type="color"]{
  -webkit-appearance: none;   /* remove iOS special control styling */
  appearance: none;
  display: block;
  width: auto;
  height: 32px;               /* consistent height */
  padding: 0;                 /* iOS adds internal padding */
  border: 1px solid #ccc;
  border-radius: 6px;         /* match other inputs */
  background: transparent;    /* prevent extra ring artefacts */
  box-shadow: none;           /* avoid odd inner shadows on iOS */
}
.modal-grid input[type="color"]::-webkit-color-swatch-wrapper{
  padding: 0;                 /* remove wrapper padding that causes oval */
  border-radius: 6px;
}
.modal-grid input[type="color"]::-webkit-color-swatch{
  border: none;               /* remove default border */
  border-radius: 6px;         /* keep corners consistent */
}
/* Quick colour presets for Overlays modal */
.swatch-row{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
  margin-bottom:6px;
}
.swatch-btn{
  width:24px;
  height:24px;
  border:1px solid #ccc;
  border-radius:6px;
  cursor:pointer;
  display:inline-block;
  box-sizing:border-box;
}
.swatch-btn:focus{ outline:2px solid #0a66ff; outline-offset:2px; }
.swatch-btn[data-color="#e74c3c"]{ background:#e74c3c; } /* red */
.swatch-btn[data-color="#3498db"]{ background:#3498db; } /* blue */
.swatch-btn[data-color="#27ae60"]{ background:#27ae60; } /* green */
.swatch-btn[data-color="#ffa500"]{ background:#ffa500; } /* orange */
.swatch-btn[data-color="#9b59b6"]{ background:#9b59b6; } /* purple */
.logline.info{color:#a5d6ff} .logline.warn{color:#ffd27f} .logline.err{color:#ffb4b4}
.infochip{padding:4px 8px;border-radius:999px;border:1px solid #e0e0e0;background:#fff;font-size:12px}
.infobar{display:block;width:100%;margin-top:8px}
.infobar-wrap{margin-top:6px}

.infobar-line{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  width:100%;
  margin:6px 0 0;
}
.infobar-line #statusChip{
  flex:1 1 50%;
  text-align:left;
}
.infobar-line #fileNameLabel{
  flex:1 1 50%;
  text-align:right;
  color: var(--muted);
  font-size:12px;
}
#twoCols{display:grid;grid-template-columns:1fr;gap:10px;height:100%}

/* Data panel should fill available height */
#dataPanel{display:flex;flex-direction:column;height:100%;min-height:0}
#jtabs{flex:0 0 auto}
#tabpanels{flex:1 1 auto;min-height:0;overflow:auto;display:block}
#tabpanels .tabpanel.active{display:block}

/* Tighter tables and labels */
.grid th,.grid td{padding:4px 6px}
label{gap:2px}

/* Default compact number/select fields */
input[type=number]{min-width:5ch;padding:4px 6px}
select{min-width:6ch;padding:4px 6px}

/* Compact grids that don't stretch full width */
.grid.auto{width:auto;display:inline-table}
.grid.compact th,.grid.compact td{padding:3px 4px}
.grid.auto th,.grid.auto td{white-space:nowrap}
.grid.compact td input[type=number]{margin:0}

/* Stages + Intergreens side-by-side */
/* Stages + Intergreens side-by-side */
.stage-ig{
  display:grid;
  grid-template-columns:max-content max-content; /* prevent tracks from stretching */
  place-items:start;              /* align + justify items at start */
  row-gap:6px;
  column-gap:4ch;
  margin-top:var(--block-gap);
}
.stage-ig > *{
  justify-self:start;
  align-self:start;
  width:max-content;              /* shrink to content instead of filling the track */
}
.stage-ig .ig-col h4{
  max-width:36ch;                 /* long header wraps and doesn't widen the column */
  white-space:normal;
}
/* pull the Intergreen column a bit left to align under the 'To previous' input */
.stage-ig .ig-col{--ig-shift:2ch;margin-left:var(--ig-shift)}
@media (max-width:760px){.stage-ig{grid-template-columns:1fr}.stage-ig .ig-col{margin-left:0}}
 .section-title{display:flex;align-items:center;gap:8px;margin:var(--block-gap) 0 6px 0}
 .section-title h4{margin:0}

/* Allow vertical shifting of the UTC Plan section */
.utc-plan-section{
  margin-top:var(--utcPlan-vshift);
}
@media (max-width:760px){.stage-ig{grid-template-columns:1fr}}

[data-t="jName"] {
  width: 15ch;
}
/* Specific compact widths for common fields */
/* 2‑char numbers (min greens, intergreens) */
[data-t="minGreen"], [data-t="ig"]{width:4ch}
/* 3‑char numbers (journey times) */
/* Journey times: allow extra room for spinner controls */
[data-t="travelPrev"], [data-t="travelNext"]{width:7ch}
/* Stage label can be short */
[data-t="stageLabel"]{width:7ch}
/* UTC "at (s)" is usually short */
[data-t="planAt"]{width:7ch;min-width:7ch}
/* Diagonal intergreens (fixed -1) also compact */
.ig-lock{width:4ch;min-width:4ch;box-sizing:border-box;text-align:center;padding:4px 6px}
</style>
</head>
<body>

<header>
  <div class="header-row">
    <h1>Signal Plan Checker <small class="muted">2.0.0</small></h1>
  </div>
  <div class="infobar-wrap">
    <div class="infobar-line">
      <span id="statusChip" class="infochip infobar">Status Message: Waiting for Validate…</span>
      <span id="fileNameLabel" class="infochip infobar">Filename: file unsaved</span>
    </div>
  </div>
</header>
 
  <div class="tabs" id="masterTabs" style="margin:8px 10px 0">
    <button class="tab active" id="tabDataBtn">Data</button>
    <button class="tab" id="tabPlotBtn" disabled>Plot</button>
    <button class="tab" id="tabDebugBtn" style="display:none">Debug</button>
    <span class="push-right"></span>
    <button id="saveAllBtn" title="Save all data (human-readable)">Save…</button>
    <button id="loadAllBtn" title="Load saved data">Load…</button>
    <input id="loadFileInput" type="file" accept=".TD2,.td2,.txt,.json,.plan" style="display:none" />
  </div>

<main>
  <section class="card" id="dataPanel">
    <!-- data panel -->
    <!-- Was the main data input card; give it an id so we can toggle tabs -->
    
    
    
    <div id="bootAlert" class="alert"></div>
    <div class="row">
      <span class="badge">Init auto-loaded</span>
      <label>Main cycle (s)<input id="mainCycle" type="number" min="1" max="240" value="60"/></label>
      <label>Junctions<input id="jCount" type="number" min="2" max="5" value="3"/></label>
      <label>View cycles
        <select id="viewCycles">
          <option value="1">1</option><option value="2" selected>2</option><option value="3">3</option>
        </select>
      </label>
  <button id="validateBtn">Validate</button>
  <button id="plotBtn" disabled>Plot</button>
    </div>
    <div class="tabs" id="jtabs"></div>
    <div id="tabpanels"></div>
  </section>

  <section id="plotPanel" class="card" style="display:none">
    <div id="plotToolbar">
      <strong>TD Diagram</strong>
      <label>Zoom (px/s)<input type="range" id="zoom" min="1" max="12" step="1" value="4"/></label>
      <button id="fitBtn">Fit</button>
      <button id="overlayBtn">Overlays…</button>
      <button id="adjustBtn">Adjust…</button>
      <label style="display:flex;align-items:center;gap:6px"><input id="guidesToggle" type="checkbox" checked> Guides</label>
      <label style="display:flex;align-items:center;gap:6px"><input id="debugToggle" type="checkbox"> Enable Debug</label>
      <span id="info" class="badge">—</span>
      <button id="copyBtn" style="margin-left:auto" title="Copy TD Diagram as image">Copy</button>
    </div>
    <div id="twoCols">
      <div style="display:flex;flex-direction:column;height:100%">
        <div id="hiddenWrap">
          <div class="plot-row">
            <canvas id="labelCanvas"></canvas>
            <div id="timelineScroll">
              <canvas id="hiddenCanvas"></canvas>
            </div>
          </div>
        </div>
      </div>
      <!-- Visible canvas removed: using hidden canvas only -->
    </div>
  </section>
  <section id="debugPanel" class="card" style="display:none">
    <div class="row">
      <button id="dbgClear">Clear</button>
      <span>Debug Log</span>
    </div>
    <div id="log"></div>
  </section>
</main>


<script>
const App = { initCfg:null, state:{ validOk:false, readyToPlot:false, pxPerSec:8, viewStartSec:0, didAutoFit:false, fileName:null, showGuides:true, temp:{ offsets:{}, boundary:{}} } };

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

function setViewStart(newStart){
  const M = App.state.mainCycle;
  const mult = (App.initCfg.plot && App.initCfg.plot.hiddenWindowMultiplier) || 5;
  const T = M * mult; // total seconds
  const C = document.getElementById('hiddenCanvas');
  const viewportSec = (C && C.width ? (C.width / (App.state.pxPerSec||1)) : 0);
  App.state.viewStartSec = clamp(newStart, 0, Math.max(0, T - viewportSec));
}

// Helper: measure the viewport width (px) excluding the label gutter
function measureViewportPx(){
  const ts = document.getElementById('timelineScroll');
  const w = ts ? Math.max(0, Math.floor(ts.getBoundingClientRect().width)) : 0;
  return Math.max(100, w);
}

// Compute vertical layout for hidden/label canvas: expand to fill, distribute rows/gaps
function computeVerticalLayout(){
  const plotCard = document.getElementById('plotPanel');
  const toolbar  = document.getElementById('plotToolbar');
  const wrap     = document.getElementById('hiddenWrap');
  const topPad   = App.initCfg.plot.topMargin || 24;
  const bottomPad= 20;
  const n        = (App.state && App.state.junctions ? App.state.junctions.length : 0) || 1;
  const minRow   = Math.max(24, App.initCfg.plot.rowHeight || 48);
  const minGap   = Math.max(8,  App.initCfg.plot.rowGap || 18);

  // Cap the canvas area to a fraction of the viewport height (configurable, default 65%)
  const vhFrac   = (App.initCfg.plot && App.initCfg.plot.maxHeightVH ? App.initCfg.plot.maxHeightVH : 0.65);
  const maxPx    = Math.floor(window.innerHeight * Math.max(0.3, Math.min(0.95, vhFrac)));

  // Measure the visible space inside the Plot card, below the toolbar
  const panelH   = plotCard ? Math.floor(plotCard.getBoundingClientRect().height) : window.innerHeight;
  const toolH    = toolbar ? Math.floor(toolbar.getBoundingClientRect().height) : 0;
  const padH     = 24; // internal padding/margins within the card

  // Usable height is min(panel content area, viewport cap, current wrapper height)
  const wrapHRaw = wrap ? Math.floor(wrap.getBoundingClientRect().height) : panelH;
  const contentH = Math.max(120, Math.min(maxPx, panelH - toolH - padH, wrapHRaw));

  let rowH = minRow, gap = minGap;
  const avail = Math.max(50, contentH - topPad - bottomPad);

  if(avail >= n * minRow){
    // keep bars at configured height, distribute extra into the gaps evenly
    gap = Math.max(minGap, Math.floor((avail - n*minRow) / Math.max(1,(n-1))));
  }else{
    // not enough space: keep a minimum gap and shrink rows uniformly
    gap = minGap;
    rowH = Math.max(16, Math.floor((avail - (n-1)*gap) / n));
  }

  const totalH = topPad + n*rowH + Math.max(0,(n-1))*gap + bottomPad;
  return { top: topPad, rowH, gap, totalH };
}

function setDirty(){
  const v=document.getElementById('validateBtn');
  const p=document.getElementById('plotBtn');
  const x=document.getElementById('transferBtn');
  if(v) v.classList.add('dirty');
  if(p){ p.classList.add('dirty'); p.disabled = true; }
  if(x){ x.disabled = true; }
  App.state.validOk=false;
  App.state.readyToPlot=false;
  setStatus('Changes detected — Validate required');
}

function log(msg, level){
  try{
    const box=document.getElementById('log'); if(!box) return;
    const d=document.createElement('div'); d.className='logline '+(level||'info'); d.textContent='['+new Date().toLocaleTimeString()+'] '+msg;
    box.appendChild(d); box.scrollTop=box.scrollHeight;
  }catch(e){}
}

function setStatus(msg){
  try{
    const chip = document.getElementById('statusChip');
    if(chip){
      chip.textContent = 'Status Message: ' + msg;
      // quick visual pulse (optional)
      chip.style.transition = 'background-color .25s';
      const old = chip.style.backgroundColor;
      chip.style.backgroundColor = '#eef9ee';
      setTimeout(()=>{ chip.style.backgroundColor = old || '#fff'; }, 250);
    }
  }catch(_){/* noop */}
}

function setFileNameLabel(name){
  const el = document.getElementById('fileNameLabel');
  if(!el) return;
  const base = (name && name.trim()) ? name.trim() : 'file unsaved';
  // Only show a timestamp when we actually have a saved/loaded file name
  let suffix = '';
  if (name && name.trim()){
    try{
      const t = new Date();
      const hh = String(t.getHours()).padStart(2,'0');
      const mm = String(t.getMinutes()).padStart(2,'0');
      suffix = ' • Last saved: ' + hh + ':' + mm;
    }catch(_){}
  }
  el.textContent = 'Filename: ' + base + suffix;
}

function ensureTD2(name){
  // Strip illegal path chars for safety and force .TD2 extension
  name = (name || '').trim().replace(/[\\\/:*?"<>|]+/g, '').replace(/\s+/g, ' ');
  if(!name) return 'My Diagram.TD2';
  if(!/\.td2$/i.test(name)) name += '.TD2';
  return name;
}

// Helper: build export object for save/load
function buildExportObject(){
  const main = { mainCycle: App.state.mainCycle, viewCycles: App.state.viewCycles };
  const junctions = (App.state.junctions||[]).map(j=>({
    id: j.id,
    name: j.name,
    doubleCycle: !!j.doubleCycle,
    travelPrev: j.travelPrev|0,
    travelNext: j.travelNext|0,
    stages: (j.stages||[]).map(s=>({ label:s.label, minGreenSec: s.minGreenSec|0 })),
    intergreen: (j.intergreen||[]).map(row=> row.slice()),
    utcPlan: (j.utcPlan||[]).map(r=>({ to:r.to, at: r.at|0 }))
  }));
  const overlays = Array.isArray(App.state._overlays)? App.state._overlays.slice() : [];
  const temp = { offsets: {...(App.state.temp&&App.state.temp.offsets||{})}, boundary: {...(App.state.temp&&App.state.temp.boundary||{})} };
  return { version: '2.0.0', exportedAt: new Date().toISOString(), main, junctions, overlays, temp };
}

function makeHumanReadableText(obj){
  const header = [
    '# Signal Plan Checker export',
    '# Version: '+(obj.version||'unknown'),
    '# Exported: '+(obj.exportedAt||new Date().toISOString()),
    '#',
    '# The JSON below contains:',
    '#  - main: mainCycle, viewCycles',
    '#  - junctions: per-junction config (stages, intergreens, utcPlan)',
    '#  - overlays: any saved overlays',
    '#  - temp: uncommitted adjustments (offsets, boundary)',
    '#',
    ''
  ].join('\n');
  return header + JSON.stringify(obj, null, 2) + '\n';
}

function parseHumanReadableText(text){
  // Strip comment lines starting with #, then parse JSON
  const json = text.split(/\r?\n/).filter(line=> !/^\s*#/.test(line)).join('\n');
  return JSON.parse(json);
}

// Enable drag-to-move on a modal by id (e.g., 'ovlModal' or 'adjModal')
function enableDragModal(modalId){
  const backdrop = document.getElementById(modalId);
  if(!backdrop) return;
  const card = backdrop.querySelector('.modal-card');
  if(!card) return;

  // Only init once per modal
  if(card.__dragInit) return; 
  card.__dragInit = true;

  // Ensure absolute positioning (CSS also sets this)
  card.style.position = 'absolute';

  // Center once on first open if no left/top set
  function centerOnce(){
    const br = backdrop.getBoundingClientRect();
    const cr = card.getBoundingClientRect();
    if(!card.style.left && !card.style.top){
      const left = Math.max(8, (br.width  - cr.width )/2);
      const top  = Math.max(8, (br.height - cr.height)/2);
      card.style.left = left + 'px';
      card.style.top  = top  + 'px';
    }
  }
  centerOnce();

  const header = card.querySelector('header') || card; // drag by header if present
  let dragging=false, startX=0, startY=0, baseLeft=0, baseTop=0;

  header.addEventListener('pointerdown', (e)=>{
    dragging = true;
    startX = e.clientX; startY = e.clientY;
    const cs = getComputedStyle(card);
    baseLeft = parseFloat(cs.left)||0; baseTop = parseFloat(cs.top)||0;
    try{ header.setPointerCapture(e.pointerId); }catch(_){}
    document.body.style.userSelect = 'none';
  });
  header.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx = e.clientX - startX; const dy = e.clientY - startY;
    const br = backdrop.getBoundingClientRect();
    const cr = card.getBoundingClientRect();
    let nl = baseLeft + dx; let nt = baseTop + dy;
    // clamp within viewport with 8px margin
    nl = Math.max(8, Math.min(br.width  - cr.width  - 8, nl));
    nt = Math.max(8, Math.min(br.height - cr.height - 8, nt));
    card.style.left = nl + 'px';
    card.style.top  = nt + 'px';
  });
  function endDrag(){ dragging=false; document.body.style.userSelect=''; }
  header.addEventListener('pointerup', endDrag);
  header.addEventListener('pointercancel', endDrag);
}

window.addEventListener('error', e=>log('ERROR: '+(e.message||e.error),'err'));
window.addEventListener('unhandledrejection', e=>log('PROMISE: '+(e.reason&&e.reason.message?e.reason.message:e.reason),'err'));

async function loadBundledInit(){
  const DEFAULT_CFG = {"appName":"Signal Plan Checker","ui":{"debug":{"enabled":true,"dock":{"showOnLoad":false},"logLevel":"info","validationOnActions":false,"perfMarkers":true}},"mainCycleTime":{"default":60,"min":1,"max":240,"mustBeEvenWhenAnyDouble":true},"junctionCount":{"default":3,"min":2,"max":5},"doubleCycle":{"allowed":true,"requireAtLeastOneMainCycle":true},"stageCount":{"default":2,"min":2},"stage":{"minGreen":{"default":7,"min":1}},"intergreen":{"diagonalLockedValue":-1,"allowNotPermittedValue":-1,"defaults":{"offDiagonal":5},"domain":{"min":0,"max":60}},"journeyTime":{"default":20,"min":0,"max":60},"utcPlan":{"requireAtLeastOneChange":true,"markRequestsBlue":true,"showQueuedChangeMarkers":true,"warnOnDelay":true,"alertOnMissedChange":true,"defaults":[{"to":"S1","at":0},{"to":"S2","at":30}]},"plot":{"hiddenWindowMultiplier":5,"viewCycles":{"options":[1,2,3],"default":2},"grid10s":true,"ticks1s":true,"ticks5s":true,"rowHeight":48,"rowGap":18,"leftMargin":120,"topMargin":24,"pxPerSec":4},"overlays":{"adjacentOnly":true,"defaultOpacity":0.8,"shadeAlpha":0.15,"repeatByCycle":true,"allowCustomIntervals":true},"packaging":{"includeDocs":true}};
  try{
    // If running from file://, avoid fetch() CORS and use inline JSON if provided
    if (location && location.protocol === 'file:'){
      const node = document.getElementById('initCfg');
      if(node && node.textContent){
        try { return JSON.parse(node.textContent); } catch(_) { /* fall through to default */ }
      }
      return DEFAULT_CFG;
    }
    // Normal case when served over http/https
    const res = await fetch('init.config.json', { cache: 'no-store' });
    if(res.ok){ return await res.json(); }
    // As a fallback, try inline JSON if present
    const node = document.getElementById('initCfg');
    if(node && node.textContent){
      try { return JSON.parse(node.textContent); } catch(_) { /* fall through */ }
    }
    return DEFAULT_CFG;
  }catch(e){
    return DEFAULT_CFG;
  }
}

function mkDefaultUTCPlan(cfg){
  return (cfg.utcPlan && Array.isArray(cfg.utcPlan.defaults)) ? JSON.parse(JSON.stringify(cfg.utcPlan.defaults)) : [{to:'S1',at:0},{to:'S2',at:30}];
}

function mkJunction(id, cfg){
  const nStages = Math.max(cfg.stageCount.min, cfg.stageCount.default);
  const stages = []; const minG = cfg.stage.minGreen.default;
  for(let i=0;i<nStages;i++){ stages.push({ label: 'S'+(i+1), minGreenSec: minG }); }
  const N = nStages; const ig = [];
  for(let r=0;r<N;r++){ const row=[]; for(let c=0;c<N;c++){ row.push(r===c ? cfg.intergreen.diagonalLockedValue : cfg.intergreen.defaults.offDiagonal); } ig.push(row); }
  return { id, name:'Junction '+id, doubleCycle:false, utcPlan: mkDefaultUTCPlan(cfg), stages, intergreen: ig, travelPrev: cfg.journeyTime.default, travelNext: cfg.journeyTime.default };
}

function buildState(cfg){
  const count = Math.max(cfg.junctionCount.min, Math.min(cfg.junctionCount.max, cfg.junctionCount.default));
  const ids = ['A','B','C','D','E'].slice(0,count);
  const juncs = ids.map(id=>mkJunction(id, cfg));
  return { ...App.state, mainCycle: Math.max(cfg.mainCycleTime.min, Math.min(cfg.mainCycleTime.max, cfg.mainCycleTime.default)), viewCycles: (cfg.plot.viewCycles && cfg.plot.viewCycles.default)||2, junctions: juncs, pxPerSec: cfg.plot.pxPerSec||4 };
}

function effectiveCycle(j){ return j.doubleCycle ? (App.state.mainCycle/2) : App.state.mainCycle; }
function stageIndex(j, label){ const idx = j.stages.findIndex(s=>s.label===label); return (idx>=0? idx : 0); }
function clampInt(v, lo, hi){ v=parseInt(v||0,10); if(isNaN(v)) v=0; return Math.max(lo, Math.min(hi, v)); }

// --- Adjusted plan helpers (global) ---
function getAdjustedPlan(j){
  const Cj = effectiveCycle(j);
  const base = (j.utcPlan||[]).slice().sort((a,b)=>a.at-b.at).map(r=>({to:r.to, at:r.at}));
  const off = (App.state.temp && App.state.temp.offsets && App.state.temp.offsets[j.id]) || 0;
  // apply offset (wrap into [0,Cj))
  if(off){
    for(let i=0;i<base.length;i++){
      let t = base[i].at + off; t %= Cj; if(t<0) t += Cj; base[i].at = t;
    }
    base.sort((a,b)=>a.at-b.at);
  }
  // apply boundary nudges (delta seconds to the change between stage i and i+1)
  const bmap = (App.state.temp && App.state.temp.boundary && App.state.temp.boundary[j.id]) || {};
  Object.keys(bmap).forEach(k=>{
    const idx = parseInt(k,10); if(!isFinite(idx)) return;
    let t = (base[idx] && base[idx].at) || 0;
    t += bmap[k];
    t %= Cj; if(t<0) t += Cj;
    if(base[idx]) base[idx].at = t;
  });
  base.sort((a,b)=>a.at-b.at);
  return base;
}
function computeRealisedCycleAdj(j){
  const jClone = JSON.parse(JSON.stringify(j));
  jClone.utcPlan = getAdjustedPlan(j);
  return computeRealisedCycle(jClone);
}
// ---- min-green realised times (from v1.1.6-alpha) ----
function computeRealisedCycle(j){
  const Cj = effectiveCycle(j);
  const plan = (j.utcPlan||[]).slice().sort((a,b)=>a.at-b.at);
  const N = plan.length;
  if(N===0) return {ok:false, err:['UTC plan empty']};
  const toIdx = plan.map(p=>stageIndex(j,p.to));
  for(let i=0;i<N;i++){
    const from = toIdx[i];
    const to = toIdx[(i+1)%N];
    if(j.intergreen[from][to] === -1){
      const a=j.stages[from].label, b=j.stages[to].label;
      return {ok:false, err:[`${j.name}: Stage move not permitted ${a} → ${b}`]};
    }
  }
  const Rq = new Array(N*2);
  for(let i=0;i<N;i++){ Rq[i]=plan[i].at; }
  for(let i=0;i<N;i++){ Rq[i+N]=plan[i].at + Cj; }
  const RC = new Array(N+1).fill(0);
  RC[0] = Rq[0];
  const details = [];
  for(let i=0;i<N;i++){
    const curIdx = toIdx[i%N];
    const prevIdx = toIdx[(i-1+N)%N];
    const nextIdx = toIdx[(i+1)%N];
    const igPrev = Math.max(0, j.intergreen[prevIdx][curIdx]);
    const mgCur = j.stages[curIdx].minGreenSec|0;
    const nextReq = Rq[i+1];
    const nextNextReq = (i+2<=N) ? Rq[i+2] : (Rq[(i+2)%(N)] + Cj);
    const stageStart = RC[i] + igPrev;
    const earliestMG = stageStart + mgCur;
    const realisedNext = Math.max(nextReq, earliestMG);
    if(realisedNext >= nextNextReq){
      const a = j.stages[curIdx].label, b=j.stages[nextIdx].label;
      return {ok:false, err:[`${j.name}: Stage change not achievable ${a} → ${b} before next request at t=${nextNextReq%Cj}s`]};
    }
    RC[i+1] = realisedNext;
    details.push({i, rqCur:Rq[i], rqNext:nextReq, rqNext2:nextNextReq, igPrev, mgCur, stageStart, earliestMG, realisedNext, delay: realisedNext - nextReq, curStage:j.stages[curIdx].label, nextStage:j.stages[nextIdx].label});
  }
  const RCmod = RC.map(t=> t % Cj);
  return {ok:true, Cj, plan, toIdx, RC, RCmod, details};
}
function travelTimeBetween(fromIdx, toIdx){
  const J = App.state.junctions;
  if(fromIdx===toIdx) return 0;
  let t = 0;
  if(toIdx>fromIdx){
    for(let i=fromIdx;i<toIdx;i++) t += (J[i].travelNext||0);
  }else{
    for(let i=fromIdx;i>toIdx;i--) t += (J[i].travelPrev||0);
  }
  return t;
}

function rowY(top, rowH, gap, idx){
  return top + idx*(rowH+gap);
}

function drawArrowMarker(ctx, x, yMid, dir){
  // dir: +1 (down), -1 (up)
  const len = 8, hw = 6; // head width
  ctx.beginPath();
  if(dir>0){
    ctx.moveTo(x, yMid - len);
    ctx.lineTo(x, yMid + len);
    ctx.moveTo(x - hw/2, yMid + len - hw);
    ctx.lineTo(x, yMid + len);
    ctx.lineTo(x + hw/2, yMid + len - hw);
  }else{
    ctx.moveTo(x, yMid + len);
    ctx.lineTo(x, yMid - len);
    ctx.moveTo(x - hw/2, yMid - len + hw);
    ctx.lineTo(x, yMid - len);
    ctx.lineTo(x + hw/2, yMid - len + hw);
  }
  ctx.stroke();
}

function drawArrowMarkerH(ctx, xMid, y){
  // small right-pointing arrow centered at (xMid, y)
  const len = 10;
  ctx.beginPath();
  ctx.moveTo(xMid - len/2, y);
  ctx.lineTo(xMid + len/2, y);
  ctx.stroke();
  // arrow head to the right
  ctx.beginPath();
  ctx.moveTo(xMid + len/2, y);
  ctx.lineTo(xMid + len/2 - 6, y - 4);
  ctx.lineTo(xMid + len/2 - 6, y + 4);
  ctx.closePath();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
}

function drawArrowHeadRight(ctx, x, y){
  // small filled triangle pointing right, with tip at (x,y)
  const size = 7;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - size, y - size*0.6);
  ctx.lineTo(x - size, y + size*0.6);
  ctx.closePath();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
}

function drawArrowLine(ctx, x1, y1, x2, y2){
  // diagonal line from (x1,y1) to (x2,y2) with an arrow head at end
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  const ang = Math.atan2(y2 - y1, x2 - x1);
  const size = 9;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - size*Math.cos(ang - Math.PI/6), y2 - size*Math.sin(ang - Math.PI/6));
  ctx.lineTo(x2 - size*Math.cos(ang + Math.PI/6), y2 - size*Math.sin(ang + Math.PI/6));
  ctx.closePath();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
}

// ---- validation
function validateJunction(j){
  const errs=[];
  j.stages.forEach((s)=>{
    if(!(Number.isInteger(s.minGreenSec) || typeof s.minGreenSec==='number')) errs.push(`${j.name}: Stage ${s.label} minGreen not a number`);
    if(s.minGreenSec < App.initCfg.stage.minGreen.min) errs.push(`${j.name}: Stage ${s.label} minGreen < ${App.initCfg.stage.minGreen.min}`);
  });
  const Cj = effectiveCycle(j);
  if((j.utcPlan||[]).length===0) errs.push(`${j.name}: UTC plan empty`);
  (j.utcPlan||[]).forEach((p,i)=>{
    if(p.at>=Cj) errs.push(`${j.name}: Plan row #${i+1} at=${p.at} ≥ cycle (${Cj})`);
    if(!j.stages.find(s=>s.label===p.to)) errs.push(`${j.name}: Plan row #${i+1} stage '${p.to}' not found`);
  });
  if(errs.length) return errs;
  const rc = computeRealisedCycle(j);
  if(!rc.ok){ errs.push(...rc.err); }
  return errs;
}

function runValidation({silent}={silent:false}){
  if(!silent) log('Validate clicked','info');
  const errs=[];
  const anyDouble = App.state.junctions.some(j=>j.doubleCycle);
  if(anyDouble && (App.state.mainCycle % 2 !== 0)) errs.push(`Main cycle must be even when any junction is double-cycling.`);
  const anyMain = App.state.junctions.some(j=>!j.doubleCycle);
  if(!anyMain) errs.push(`At least one junction must run the main cycle (not double).`);
  App.state.junctions.forEach(j=>errs.push(...validateJunction(j)));
  const ok = errs.length===0;
  if(ok){
    App.state.validOk = true;
    const v=document.getElementById('validateBtn'); if(v) v.classList.remove('dirty');
    setStatus('Validated ✔ — press Plot to render');
    const plot=document.getElementById('plotBtn'); if(plot) plot.disabled=false;
    const x=document.getElementById('transferBtn'); if(x) x.disabled=false;
    if(!silent) log('VALIDATION OK','info');
    const ba=document.getElementById('bootAlert'); if(ba){ ba.classList.remove('show'); ba.textContent=''; }
  }else{
    App.state.validOk = false;
    setStatus('Validation failed — see alerts');
    const plot=document.getElementById('plotBtn'); if(plot) plot.disabled=true;
    const x=document.getElementById('transferBtn'); if(x) x.disabled=true;
    const msg = 'Fix these first:\n - '+errs.join('\n - ');
    if(silent){
      const ba=document.getElementById('bootAlert'); if(ba){ ba.classList.add('show'); ba.textContent = msg; }
      log('BOOT VALIDATION FAIL: '+errs.join(' | '),'warn');
    }else{
      alert(msg);
      log('VALIDATION FAIL: '+errs.join(' | '),'warn');
    }
  }
  return ok;
}

// ---- drawing hidden
function drawHidden(){
  if(!(App.state.validOk && App.state.readyToPlot)){
    log('Draw suppressed (requires Validate OK + Plot)','warn');
    return;
  }

  const scroller = document.getElementById('timelineScroll');
  const C = document.getElementById('hiddenCanvas');
  const ctx = C.getContext('2d');

  const M = App.state.mainCycle;                                 // main cycle seconds (e.g., 60)
  const mult = (App.initCfg.plot && App.initCfg.plot.hiddenWindowMultiplier) || 5;
  const T = M * mult;                                            // total world seconds
  let pps = App.state.pxPerSec || 4;                           // pixels per second

  // Use dynamic vertical layout
  const { top, rowH, gap, totalH } = computeVerticalLayout();

  // Viewport width is the visible width of the scroll container — canvas does NOT grow with zoom
  const viewportPx = measureViewportPx();
  C.width  = viewportPx;                                         // drawing buffer width matches viewport
  const height = totalH;
  C.height = height;

  // Compute visible window [v0, v1] in seconds and clamp to the time horizon [0, T]
  let viewDurSec = viewportPx / pps;                             // how many seconds fit in the viewport

  // If the viewport can show more than the total horizon, rescale px/sec so that the window exactly fits T
  if (T > 0 && viewDurSec > T) {
    App.state.pxPerSec = Math.max(1, viewportPx / T);
    pps = App.state.pxPerSec;
    viewDurSec = viewportPx / App.state.pxPerSec;
    setViewStart(0); // start at the left edge
  } else {
    // Otherwise just clamp the start to the available range [0, T - viewDurSec]
    setViewStart(App.state.viewStartSec);
  }

  let v0 = App.state.viewStartSec;                               // left edge time (s)
  let v1 = v0 + viewDurSec;                                      // right edge time (s)

  // Final guard: never render past the horizon
  if (v1 > T) {
    v1 = T;
    v0 = Math.max(0, T - viewDurSec);
    App.state.viewStartSec = v0;                                 // keep state consistent
  }

  // Background
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,C.width,C.height);

  // Grid + tick marks (1s/5s/10s) inside the viewport only
  const yTop    = top;           // top edge of rows
  const yTopTickBase = top;      // where ticks attach on top
  const yBot    = height - 10;   // bottom guideline
  const yBotTickBase = height - 10;

  const sStart = Math.floor(v0);
  const sEnd   = Math.ceil(v1);

  for(let s = sStart; s <= sEnd; s++){
    const x = (s - v0) * pps;

    // subtle vertical gridlines at 5s (lighter than 10s main grid)
    if (App.state.showGuides && s % 5 === 0 && s % 10 !== 0) {
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)'; // very light
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x, yTop); ctx.lineTo(x, yBot); ctx.stroke();
      ctx.restore();
    }

    if(s % 10 === 0){
      // 10s: full vertical grid + longest ticks
      ctx.strokeStyle = '#d0d0d0'; // slightly darker grid line
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x, yTop-8); ctx.lineTo(x, yBot); ctx.stroke();

      // long ticks
      ctx.strokeStyle = '#000';
      ctx.beginPath(); ctx.moveTo(x, yTopTickBase); ctx.lineTo(x, yTopTickBase - 10); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, yBotTickBase); ctx.lineTo(x, yBotTickBase + 10); ctx.stroke();

      // top labels show offset from the start of the first cycle
      ctx.fillStyle='#000'; ctx.font='10px system-ui'; ctx.textAlign='center'; ctx.textBaseline='alphabetic';
      ctx.fillText(String(Math.round(s - M)), x, yTop-12);
    } else if(s % 5 === 0){
      // 5s: medium ticks, no full grid line
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x, yTopTickBase); ctx.lineTo(x, yTopTickBase - 6); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, yBotTickBase); ctx.lineTo(x, yBotTickBase + 6); ctx.stroke();
    } else {
      // 1s: short ticks
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x, yTopTickBase); ctx.lineTo(x, yTopTickBase - 3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, yBotTickBase); ctx.lineTo(x, yBotTickBase + 3); ctx.stroke();
    }
  }

  // Red cycle markers at every multiple of mainCycle
  (function(){
    const Cj = App.state.mainCycle || 60;
    if(!Cj) return;
    const kStart = Math.ceil(v0 / Cj);
    const kEnd   = Math.floor(v1 / Cj);
    ctx.save();
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    for(let k=kStart; k<=kEnd; k++){
      const t = k * Cj;
      const x = (t - v0) * pps;
      ctx.beginPath();
      ctx.moveTo(x, yTop);
      ctx.lineTo(x, yBot);
      ctx.stroke();
    }
    ctx.restore();
  })();

  // Bottom labels (absolute seconds)
  (function(){
    try{
      const y = height - 6;
      ctx.save();
      ctx.fillStyle = '#000';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
      
      const tick0 = Math.ceil(v0 / 10) * 10;   // first 10-sec mark at or to the right of v0
      for (let t = tick0; t <= v1; t += 10) {
        const x = (t - v0) * pps; ctx.fillText(String(Math.round(t)), x, y - 3);
      }
      ctx.restore();
    }catch(e){}
  })();

  const greens = ['rgba(60,180,75,0.9)','rgba(90,205,105,0.9)','rgba(120,220,135,0.9)','rgba(150,235,165,0.9)'];

  // Draw rows clipped to viewport [v0, v1]
  App.state.junctions.forEach((j, idx)=>{
    const y0 = top + idx*(rowH+gap);
    ctx.strokeStyle = '#ddd'; ctx.strokeRect(0, y0, viewportPx, rowH);
    // Row-level tick bar (replicates the top time ticks for each junction row)
    if (App.state.showGuides) (function(){
      const sStartRow = Math.floor(v0);
      const sEndRow   = Math.ceil(v1);
      for(let ss = sStartRow; ss <= sEndRow; ss++){
        const xx = (ss - v0) * pps;
        // 10s: longest ticks; 5s: medium; 1s: short
        if(ss % 10 === 0){
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(xx, y0); ctx.lineTo(xx, y0 - 10); ctx.stroke();
        } else if(ss % 5 === 0){
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(xx, y0); ctx.lineTo(xx, y0 - 6); ctx.stroke();
        } else {
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(xx, y0); ctx.lineTo(xx, y0 - 3); ctx.stroke();
        }
      }
    })();

    // For the top junction (A), draw a mirrored tick bar below the green bar
    if (App.state.showGuides) (function(){
      if (idx !== 0) return; // only for the very first (top) junction row
      const sStartRow = Math.floor(v0);
      const sEndRow   = Math.ceil(v1);
      const yBase = y0 + rowH; // bottom edge of the row's bar area
      for(let ss = sStartRow; ss <= sEndRow; ss++){
        const xx = (ss - v0) * pps;
        // 10s: longest ticks downward; 5s: medium; 1s: short
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        if(ss % 10 === 0){
          ctx.beginPath(); ctx.moveTo(xx, yBase); ctx.lineTo(xx, yBase + 10); ctx.stroke();
        } else if(ss % 5 === 0){
          ctx.beginPath(); ctx.moveTo(xx, yBase); ctx.lineTo(xx, yBase + 6); ctx.stroke();
        } else {
          ctx.beginPath(); ctx.moveTo(xx, yBase); ctx.lineTo(xx, yBase + 3); ctx.stroke();
        }
      }
    })();

    const rc = computeRealisedCycleAdj(j);
    if(!rc.ok){ ctx.fillStyle = '#b00020'; ctx.fillText('ERR: '+rc.err.join(' | '), 8, y0+14); return; }

    const Cj = rc.Cj; const N = rc.plan.length; const cycles = Math.ceil(T / Cj);

    for(let k=0;k<cycles;k++){
      const base = k*Cj;
      // Requested change markers
      if(App.initCfg.utcPlan.markRequestsBlue){
        ctx.strokeStyle = '#4aa1ff'; ctx.lineWidth=2;
        for(let i=0;i<N;i++){
          const rqAbs = base + rc.plan[i].at;
          if(rqAbs < v0 || rqAbs > v1) continue;                  // outside viewport
          const x= (rqAbs - v0) * pps; ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+rowH); ctx.stroke();
        }
      }

      for(let i=0;i<N;i++){
        const curIdx = rc.toIdx[i];
        const prevIdx = rc.toIdx[(i-1+N)%N];
        const nextIdx = rc.toIdx[(i+1)%N];

        const igPrev = Math.max(0, j.intergreen[prevIdx][curIdx]);
        const RCi = rc.RC[i];
        const RCn = rc.RC[i+1];

        const segStartAbs = base + (RCi + igPrev);
        const segEndAbs   = base + RCn;
        const s = Math.max(v0, segStartAbs);
        const e = Math.min(v1, segEndAbs);
        if(e > s){
          ctx.fillStyle = greens[curIdx % greens.length];
          ctx.fillRect((s - v0)*pps, y0+6, (e - s)*pps, rowH-12);
          // Stage label centered in the green bar
          const wpx = (e - s) * pps;
          if(wpx >= 28){
            const xMid = ((s + e)/2 - v0) * pps;
            const yMid = y0 + rowH/2;
            const fs = Math.min(14, Math.max(10, Math.floor(rowH * 0.36)));
            ctx.save();
            ctx.font = fs + 'px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // subtle shadow for contrast on green backgrounds
            ctx.shadowColor = 'rgba(0,0,0,0.45)';
            ctx.shadowBlur = 3;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(j.stages[curIdx].label, xMid, yMid);
            ctx.restore();
          }
          // Start/End time labels (relative to junction cycle Cj)
          // Start is (RCi + igPrev) modulo Cj; End is RCn modulo Cj
          const tStartC = ((RCi + igPrev) % Cj + Cj) % Cj; // normalized into [0, Cj)
          const tEndC   = ((RCn) % Cj + Cj) % Cj;

          ctx.save();
          ctx.fillStyle = '#000';
          ctx.font = '10px system-ui';
          // Place labels above the per-row tick marks for most rows,
          // but for the TOP junction row (idx === 0) place them *below* the bar
          // so they don't clash with the main timing bar at the very top.
          const isTopRow = (idx === 0);
          const yLabel = isTopRow ? (y0 + rowH + 12) : (y0 - 12);
          ctx.textBaseline = isTopRow ? 'top' : 'bottom';
          ctx.textAlign = 'center';

          // Draw start label if the start tick is within the viewport
          if(segStartAbs >= v0 && segStartAbs <= v1){
            const xStart = (segStartAbs - v0) * pps;
            ctx.fillText(String(Math.round(tStartC)), xStart, yLabel);
          }
          // Draw end label if the end tick is within the viewport
          if(segEndAbs >= v0 && segEndAbs <= v1){
            const xEnd = (segEndAbs - v0) * pps;
            ctx.fillText(String(Math.round(tEndC)), xEnd, yLabel);
          }
          ctx.restore();
        }

        // --- tiny blue triangle indicators on nearest tick to start/end (pointing toward the green bar)
        if (App.state.showGuides) (function(){
          // Skip if segment is completely outside viewport
          if(!(segEndAbs >= v0 && segStartAbs <= v1)) return;

          // Round to nearest second to align with tick marks
          const tStartTick = Math.round(segStartAbs);
          const tEndTick   = Math.round(segEndAbs);

          // Compute x positions (only draw if inside viewport)
          const xStartTick = (tStartTick - v0) * pps;
          const xEndTick   = (tEndTick   - v0) * pps;

          // Triangle size
          const tri = 6;

          const isTopRow = (idx === 0);
          // Triangle apex sits exactly on the tick base line
          //  • non-top rows: ticks are drawn upward from y0, so base = y0
          //  • top row (A): mirrored ticks are drawn downward from y0+rowH, so base = y0 + rowH
          const yBase = isTopRow ? (y0 + rowH) : y0;

          ctx.save();
          ctx.fillStyle = '#1e88ff';   // blue
          ctx.strokeStyle = '#1e88ff';

          // Helper to draw an isosceles triangle pointing up or down
          function drawTriangle(xc, yBase, dirDown){
            ctx.beginPath();
            if (dirDown){
              // point DOWN: apex at yBase, base above
              ctx.moveTo(xc, yBase);
              ctx.lineTo(xc - tri*0.7, yBase - tri);
              ctx.lineTo(xc + tri*0.7, yBase - tri);
            } else {
              // point UP: apex at yBase, base below
              ctx.moveTo(xc, yBase);
              ctx.lineTo(xc - tri*0.7, yBase + tri);
              ctx.lineTo(xc + tri*0.7, yBase + tri);
            }
            ctx.closePath();
            ctx.fill();
          }

          // Start triangle
          if (tStartTick >= Math.floor(v0) && tStartTick <= Math.ceil(v1)) {
            drawTriangle(xStartTick, yBase, /*dirDown=*/ !isTopRow);
          }
          // End triangle
          if (tEndTick >= Math.floor(v0) && tEndTick <= Math.ceil(v1)) {
            drawTriangle(xEndTick, yBase, /*dirDown=*/ !isTopRow);
          }

          ctx.restore();
        })();

        // queued change delay marker (clipped)
        const nextReqAbs = base + rc.details[i].rqNext;
        const delay = rc.details[i].delay;
        if(App.initCfg.utcPlan.showQueuedChangeMarkers && delay>0){
          const x1s = Math.max(v0, nextReqAbs), x2s = Math.max(v0, Math.min(v1, base + RCn));
          if(x2s > x1s){
            ctx.strokeStyle='rgba(74,161,255,0.7)'; ctx.setLineDash([4,3]);
            const x1=(x1s - v0)*pps, x2=(x2s - v0)*pps; ctx.beginPath(); ctx.moveTo(x1, y0+4); ctx.lineTo(x2, y0+4); ctx.stroke(); ctx.setLineDash([]);
            ctx.fillStyle='rgba(74,161,255,0.9)'; ctx.beginPath(); ctx.moveTo(x2, y0+4); ctx.lineTo(x2-5, y0-4); ctx.lineTo(x2+5, y0-4); ctx.closePath(); ctx.fill();
          }
        }

        // intergreen shading (clipped)
        const igNext = Math.max(0, j.intergreen[curIdx][nextIdx]);
        if(igNext>0){
          const igStartAbs = base + RCn, igEndAbs = igStartAbs + igNext;
          const is = Math.max(v0, igStartAbs), ie = Math.min(v1, igEndAbs);
          if(ie>is){ ctx.fillStyle = 'rgba(150,150,150,0.35)'; ctx.fillRect((is-v0)*pps, y0+6, (ie-is)*pps, rowH-12); }
        }
      }
    }
  });
  // ---- Journey overlays (shaded polygons + direction arrows) ----
  if(Array.isArray(App.state._overlays)){
    App.state._overlays.forEach(ovl=>{
      const fromIdx = ovl.from, toIdx = ovl.to;
      if(fromIdx==null || toIdx==null) return;
      const Jfrom = App.state.junctions[fromIdx];
      const rcFrom = computeRealisedCycleAdj(Jfrom);
      if(!rcFrom.ok) return;
      const travel = travelTimeBetween(fromIdx, toIdx);

      const yFrom = rowY(top, rowH, gap, fromIdx);
      const yTo   = rowY(top, rowH, gap, toIdx);
      const yFromTop = yFrom+6, yFromBot = yFrom+rowH-6;
      const yToTop   = yTo+6,   yToBot   = yTo+rowH-6;
      const yMidFrom = (yFromTop + yFromBot)/2;
      const yMidTo   = (yToTop + yToBot)/2;
      const dir = (toIdx>fromIdx) ? +1 : (toIdx<fromIdx ? -1 : 0);

      const Cj = rcFrom.Cj;
      // Determine which cycles to evaluate so that either upstream or downstream windows intersect the viewport
      const kMin = Math.floor((v0 - travel)/Cj) - 1;
      const kMax = Math.ceil((v1)/Cj) + 1;

      for(let k=kMin; k<=kMax; k++){
        const base = k*Cj;
        
        for(let i=0;i<rcFrom.details.length;i++){
          if(ovl.mode === 'time' && i > 0) continue; // time-based: single window per cycle
  const d = rcFrom.details[i];
  let tStartAbs, tEndAbs;
  if(ovl.mode === 'time'){
    tStartAbs = base + (ovl.start||0);
    tEndAbs   = base + Math.max(ovl.start||0, ovl.end||0);
  }else{ // stage-based (default)
    if(ovl.stage && d.curStage !== ovl.stage) continue;
    tStartAbs = base + d.stageStart;      // at(s) + preceding intergreen
    tEndAbs   = base + rcFrom.RC[i+1];    // max(next request, start + minGreen)
  }
        
        
        
        
        
          if(!(tEndAbs > tStartAbs)) continue;

          // Downstream arrival window = upstream window shifted by travel time
          const aStart = tStartAbs + travel;
          const aEnd   = tEndAbs + travel;

          // Cull if completely out of viewport
          if(aStart > v1+5 || tEndAbs < v0-5) continue;

          const xS  = (tStartAbs - v0) * pps;
          const xE  = (tEndAbs   - v0) * pps;
          const xAS = (aStart    - v0) * pps;
          const xAE = (aEnd      - v0) * pps;

          // Decide line heights based on direction
          const yFromLine = (toIdx>fromIdx) ? yFromBot : yFromTop;  // base for downward, top for upward
          const yToLine   = (toIdx>fromIdx) ? yToTop   : yToBot;    // top for downward, bottom for upward

          ctx.save();
          // Shaded polygon connecting the chosen edges of upstream and downstream windows
          ctx.globalAlpha = Math.max(0.05, Math.min(0.95, ovl.alpha || App.initCfg.overlays.shadeAlpha || 0.3));
          ctx.fillStyle = ovl.color || 'rgba(255,165,0,0.25)';
          ctx.beginPath();
          ctx.moveTo(xS,  yFromLine);
          ctx.lineTo(xAS, yToLine);
          ctx.lineTo(xAE, yToLine);
          ctx.lineTo(xE,  yFromLine);
          ctx.closePath();
          ctx.fill();

          // Dashed horizontal windows drawn on those edges
          ctx.globalAlpha = 1;
          ctx.strokeStyle = ovl.color || '#ffa500';
          ctx.lineWidth = 2;
          ctx.setLineDash([6,4]);
          // Upstream release window (horizontal)
          ctx.beginPath(); ctx.moveTo(xS,  yFromLine); ctx.lineTo(xE,  yFromLine); ctx.stroke();
          // Downstream arrival window (horizontal)
          ctx.beginPath(); ctx.moveTo(xAS, yToLine);   ctx.lineTo(xAE, yToLine);   ctx.stroke();
          ctx.setLineDash([]);

          // choose upstream/downstream edges nearest in time to tighten the diagonal endpoints
          const aMid = (aStart + aEnd) / 2;
          const tMid = (tStartAbs + tEndAbs) / 2;
          const upEdgeT   = (Math.abs(tStartAbs - aMid) <= Math.abs(tEndAbs - aMid)) ? tStartAbs : tEndAbs;
          const downEdgeT = (Math.abs(aStart   - tMid) <= Math.abs(aEnd    - tMid)) ? aStart   : aEnd;
          const xUpEdge   = (upEdgeT   - v0) * pps;
          const xDownEdge = (downEdgeT - v0) * pps;

          // Timeline arrows at the right ends of the windows (always forward in time)
          drawArrowHeadRight(ctx, xE,  yFromLine);
          drawArrowHeadRight(ctx, xAE, yToLine);



          // (Label removed)
          ctx.restore();
        }
      }
    });
  }
  const info = document.getElementById('info');
  if(info) info.textContent = `View ${viewDurSec.toFixed(1)}s @ ${pps}px/s · t=[${v0.toFixed(1)}, ${v1.toFixed(1)}] · canvas ${C.width}×${C.height}`;
  log('Hidden canvas redrawn (viewport-fixed)','info');
}

function drawLabels(){
  const label = document.getElementById('labelCanvas');
  const scroller = document.getElementById('timelineScroll');
  if(!label || !scroller) return;
  const lctx = label.getContext('2d');
  const labelW = App.initCfg.plot.leftMargin || 120;
  const { top, rowH, gap, totalH } = computeVerticalLayout();
  const height = totalH;
  // size label canvas to full content height
  label.width = labelW;
  label.height = height;
  // background
  lctx.fillStyle = '#fff';
  lctx.fillRect(0,0,label.width,label.height);
  lctx.fillStyle = '#111';
  lctx.font = '12px system-ui';
  App.state.junctions.forEach((j, idx)=>{
    const y0 = top + idx*(rowH+gap);
    lctx.fillText(j.name, 12, y0 + rowH*0.6);
  });
  // Between-junction journey times in the left margin (A→B down, B→A up)
  try{
    const juncs = App.state.junctions||[];
    lctx.save();
    lctx.font = '11px system-ui';
    lctx.textAlign = 'right';
    lctx.textBaseline = 'middle';
    lctx.fillStyle = '#333';
    const xRight = labelW - 8; // right edge inside the gutter
    for(let i=0;i<juncs.length-1;i++){
      const a = juncs[i], b = juncs[i+1];
      const y0 = top + i*(rowH+gap);
      const midY = y0 + rowH + (gap/2);
      const downSec = (a && typeof a.travelNext==='number') ? a.travelNext : 0; // A→B
      const upSec   = (b && typeof b.travelPrev==='number') ? b.travelPrev : 0; // B→A
      // Render two stacked lines: up above, down below, tightly spaced
      const dy = Math.min(10, Math.max(6, Math.floor(gap*0.3)));
      // Up arrow (B→A)
      lctx.fillText(`↑ ${upSec}s`, xRight, midY - dy);
      // Down arrow (A→B)
      lctx.fillText(`↓ ${downSec}s`, xRight, midY + dy);
    }
    lctx.restore();
  }catch(_){/* ignore */}
}


// ---- UI rendering (same as v1.1.6) ----
function renderUTCEditor(j){
  let rows=''; (j.utcPlan||[]).forEach((r,i)=>{
    rows += `<tr>
      <td><select data-t="planTo" data-id="${j.id}" data-idx="${i}">
        ${j.stages.map(s=>`<option value="${s.label}" ${r.to===s.label?'selected':''}>${s.label}</option>`).join('')}
      </select></td>
      <td><input type="number" min="0" step="1" value="${r.at}" data-t="planAt" data-id="${j.id}" data-idx="${i}"></td>
      <td><button data-t="planDel" data-id="${j.id}" data-idx="${i}">Delete</button></td>
    </tr>`;
  });
  return `<div class="utc-plan-section">
  <div class="section-title"><h4>UTC Plan</h4><button data-t="planAdd" data-id="${j.id}">Add change</button></div>
  <table class="grid compact auto"><thead><tr><th>To stage</th><th>Force Stage at<br/>(s)</th><th></th></tr></thead><tbody>${rows}</tbody></table>
  </div>`;
}

function renderJunctionPanel(j){
  const cfg = App.initCfg; const N=j.stages.length;
  let rows = '';
  for(let i=0;i<N;i++){
    rows += `<tr>
      <td><input data-t="stageLabel" data-id="${j.id}" data-idx="${i}" value="${j.stages[i].label}"></td>
      <td><input type="number" min="${cfg.stage.minGreen.min}" value="${j.stages[i].minGreenSec}" data-t="minGreen" data-id="${j.id}" data-idx="${i}"></td>
    </tr>`;
  }
  let ig = '<table class="grid compact auto"><thead><tr><th>From \\ To</th>';
  for(let c=0;c<N;c++){ ig += `<th>${j.stages[c].label}</th>`; }
  ig += '</tr></thead><tbody>';
  for(let r=0;r<N;r++){
    ig += `<tr><th>${j.stages[r].label}</th>`;
    for(let c=0;c<N;c++){
      if(r===c){ ig += `<td><input class="ig-lock" value="${cfg.intergreen.diagonalLockedValue}" disabled></td>`; }
      else{ ig += `<td><input type="number" step="1" min="-1" max="${cfg.intergreen.domain.max}" value="${j.intergreen[r][c]}" data-t="ig" data-id="${j.id}" data-r="${r}" data-c="${c}"></td>`; }
    }
    ig += '</tr>';
  }
  ig += '</tbody></table>';

return `
  <div class="row">
    <label>Name
      <input data-t="jName" data-id="${j.id}" value="${j.name}">
    </label>
    <label>Double cycle <input type="checkbox" data-t="double" data-id="${j.id}" ${j.doubleCycle?'checked':''}></label>
    <label>To previous (↑)<input type="number" min="${App.initCfg.journeyTime.min}" max="${App.initCfg.journeyTime.max}" value="${j.travelPrev}" data-t="travelPrev" data-id="${j.id}"></label>
    <label>To next (↓)<input type="number" min="${App.initCfg.journeyTime.min}" max="${App.initCfg.journeyTime.max}" value="${j.travelNext}" data-t="travelNext" data-id="${j.id}"></label>
    <label>Stage count<input type="number" min="${App.initCfg.stageCount.min}" max="8" value="${j.stages.length}" data-t="stageCount" data-id="${j.id}"></label>
  </div>

  <div class="stage-ig">
    <div>
      <h4>Stages</h4>
      <table class="grid compact auto">
        <thead><tr><th>Label</th><th>Min green (s)</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
    <div class="ig-col">
      <h4>Intergreen matrix (leading intergreen; -1 = not permitted)</h4>
      ${ig}
    </div>
  </div>

  ${renderUTCEditor(j)}
`;





  
  
  









  
}

function rebuildTabs(){
  const tabs = document.getElementById('jtabs'); const panels = document.getElementById('tabpanels'); tabs.innerHTML=''; panels.innerHTML='';
  App.state.junctions.forEach((j, idx)=>{
    const t=document.createElement('button'); t.className='tab'+(idx===0?' active':''); t.textContent=j.name; t.dataset.id=j.id;
    t.addEventListener('click', ()=>{ document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active')); t.classList.add('active');
      document.querySelectorAll('.tabpanel').forEach(p=>p.classList.remove('active')); document.getElementById('tp_'+j.id).classList.add('active'); });
    tabs.appendChild(t);
    const tp=document.createElement('div'); tp.id='tp_'+j.id; tp.className='tabpanel'+(idx===0?' active':'');
    tp.innerHTML = renderJunctionPanel(j);
    panels.appendChild(tp);
  });
  wirePanelInputs();
  log('Junction tabs rendered','info');
}

function wirePanelInputs(){
  document.querySelectorAll('[data-t]').forEach(inp=>{
    const t=inp.getAttribute('data-t');
    if(t==='planAdd' || t==='planDel'){ inp.addEventListener('click', (e)=>{ onUTCEdit(e); setDirty(); }); }
    else{
      inp.addEventListener('change', (e)=>{ onPanelChange(e); setDirty(); });
      inp.addEventListener('blur',   (e)=>{ onPanelChange(e); setDirty(); });
    }
  });
}
function findJ(id){ return App.state.junctions.find(x=>x.id===id); }

function onUTCEdit(e){
  const t = e.target.getAttribute('data-t'); const id=e.target.getAttribute('data-id'); const j=findJ(id); if(!j) return;
  if(t==='planAdd'){ j.utcPlan.push({to:(j.stages[0]&&j.stages[0].label)||'S1', at:0}); rebuildTabs(); return; }
  if(t==='planDel'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan.splice(idx,1); rebuildTabs(); return; }
}

function onPanelChange(e){
  const t=e.target.getAttribute('data-t'); const id=e.target.getAttribute('data-id');
  const j=findJ(id); if(!j) return;
  if(t==='jName'){
    const v = (e.target.value || '').toString().slice(0,14).trim();
    j.name = v || j.name; // keep old if blank
    e.target.value = j.name;
    rebuildTabs();
    return;
  }
  if(t==='double'){ j.doubleCycle = e.target.checked; }
  if(t==='travelPrev'){ j.travelPrev = clampInt(e.target.value, App.initCfg.journeyTime.min, App.initCfg.journeyTime.max); e.target.value=j.travelPrev; }
  if(t==='travelNext'){ j.travelNext = clampInt(e.target.value, App.initCfg.journeyTime.min, App.initCfg.journeyTime.max); e.target.value=j.travelNext; }
  if(t==='stageCount'){ const n = Math.max(App.initCfg.stageCount.min, Math.min(8, parseInt(e.target.value||2,10))); resizeStages(j, n); rebuildTabs(); }
  if(t==='stageLabel'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].label = e.target.value|| ('S'+(idx+1)); rebuildTabs(); }
  if(t==='minGreen'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].minGreenSec = Math.max(App.initCfg.stage.minGreen.min, parseInt(e.target.value||App.initCfg.stage.minGreen.default,10)); e.target.value=j.stages[idx].minGreenSec; }
  if(t==='ig'){ const r=parseInt(e.target.getAttribute('data-r'),10), c=parseInt(e.target.getAttribute('data-c'),10);
    let v = parseInt(e.target.value||0,10); if(v!==-1) v = Math.max(App.initCfg.intergreen.domain.min, Math.min(App.initCfg.intergreen.domain.max, v));
    j.intergreen[r][c] = v; e.target.value = v; }
  if(t==='planTo'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan[idx].to = e.target.value; }
  if(t==='planAt'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan[idx].at = Math.max(0, parseInt(e.target.value||0,10)); }
}

function resizeStages(j, n){
  const minG = App.initCfg.stage.minGreen.default;
  while(j.stages.length < n){ j.stages.push({label:'S'+(j.stages.length+1), minGreenSec:minG}); }
  while(j.stages.length > n){ j.stages.pop(); }
  const N = j.stages.length;
  const igNew = [];
  for(let r=0;r<N;r++){ const row=[]; for(let c=0;c<N;c++){ row.push(r===c ? App.initCfg.intergreen.diagonalLockedValue : (j.intergreen[r] && typeof j.intergreen[r][c]==='number' ? j.intergreen[r][c] : App.initCfg.intergreen.defaults.offDiagonal)); } igNew.push(row); }
  j.intergreen = igNew;
  j.utcPlan.forEach(p=>{ if(!j.stages.find(s=>s.label===p.to)) p.to = j.stages[0].label; });
}

// ---- boot
async function boot(){
  App.initCfg = await loadBundledInit();
  setFileNameLabel(App.state.fileName);
  const dbgPanel = document.getElementById('debugPanel');
  const debugTabBtn = document.getElementById('tabDebugBtn');
  const urlHasDebugFlag = /[?&]debug=1\b/.test(location.search);
  const debugTabVisible = !!(debugTabBtn && getComputedStyle(debugTabBtn).display !== 'none');
  const wantDebugOnLoad = urlHasDebugFlag && debugTabVisible;
  if (wantDebugOnLoad && window.__showPanel) { window.__showPanel('debug'); }
  document.getElementById('dbgClear').addEventListener('click', ()=>{ document.getElementById('log').textContent=''; });

  App.state = buildState(App.initCfg);
  // Pre-plot default: choose px/s so [mainCycle, mainCycle*viewCycles] fills the viewport
  (function(){
    const vp = measureViewportPx();
    const Cj = App.state.mainCycle;
    const N  = App.state.viewCycles || 2;
    if(vp > 0 && Cj){
      App.state.pxPerSec = Math.max(1, Math.round(vp / (N*Cj)));
      setViewStart(Cj);
      const zoom = document.getElementById('zoom');
      if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
    }
  })();
  // Guides toggle (gridlines, row ticks, blue triangles)
  const guidesToggle = document.getElementById('guidesToggle');
  if (guidesToggle) {
    guidesToggle.checked = !!App.state.showGuides;
    guidesToggle.addEventListener('change', () => {
      App.state.showGuides = !!guidesToggle.checked;
      if (App.state.readyToPlot && App.state.validOk) { drawHidden(); }
      setStatus(App.state.showGuides ? 'Guides enabled' : 'Guides disabled');
    });
  }
  // Debug toggle: show/hide Debug tab (default OFF)
  const debugToggle = document.getElementById('debugToggle');
  // debugTabBtn already declared as const above; do not reassign.
  if (debugToggle && debugTabBtn) {
    // Default to OFF and ensure hidden
    debugToggle.checked = false;
    debugTabBtn.style.display = 'none';

    debugToggle.addEventListener('change', () => {
      if (debugToggle.checked) {
        debugTabBtn.style.display = 'inline-block';
        setStatus('Debug enabled');
      } else {
        debugTabBtn.style.display = 'none';
        // If debug panel is visible, hide it
        const debugPanel = document.getElementById('debugPanel');
        if (debugPanel) debugPanel.style.display = 'none';
        setStatus('Debug disabled');
      }
    });
  }
  document.getElementById('mainCycle').value = App.state.mainCycle;
  document.getElementById('jCount').value = App.state.junctions.length;
  document.getElementById('viewCycles').value = String(App.state.viewCycles);
  rebuildTabs();
  setDirty(); // force validation before any plot
  log('App booted — smoke-check…','info');

  // Boot-time smoke-check (silent)
  runValidation({silent:true});

  document.getElementById('mainCycle').addEventListener('change', (e)=>{
    const v=parseInt(e.target.value||60,10);
    const clamped=Math.max(App.initCfg.mainCycleTime.min, Math.min(App.initCfg.mainCycleTime.max, v));
    App.state.mainCycle=clamped; e.target.value=clamped; setDirty();
    // Pre-plot: choose px/s so [C, C*N] fits the viewport
    if(!App.state.readyToPlot){
      const vp = measureViewportPx();
      const N = App.state.viewCycles || 2;
      App.state.pxPerSec = Math.max(1, Math.round(vp / (N*App.state.mainCycle)));
      setViewStart(App.state.mainCycle);
      const zoom = document.getElementById('zoom');
      if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
    }
  });
  document.getElementById('jCount').addEventListener('change', (e)=>{
    const v=parseInt(e.target.value||3,10);
    const c=Math.max(App.initCfg.junctionCount.min, Math.min(App.initCfg.junctionCount.max, v));
    const cur=App.state.junctions.length; const ids=['A','B','C','D','E'];
    if(c>cur){ for(let i=cur;i<c;i++) App.state.junctions.push(mkJunction(ids[i], App.initCfg)); }
    else if(c<cur){ App.state.junctions.splice(c); }
    e.target.value=c; rebuildTabs(); setDirty();
  });
  document.getElementById('viewCycles').addEventListener('change', (e)=>{
    App.state.viewCycles=parseInt(e.target.value||2,10);
    setDirty();
    // Pre-plot: recompute to keep [C, C*N]
    if(!App.state.readyToPlot){
      const vp = measureViewportPx();
      const Cj = App.state.mainCycle;
      const N  = App.state.viewCycles || 2;
      if(vp>0 && Cj){
        App.state.pxPerSec = Math.max(1, Math.round(vp / (N*Cj)));
        setViewStart(Cj);
        const zoom = document.getElementById('zoom');
        if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
      }
    }
  });

  // === Save/Load (human-readable) ===
  const saveBtn = document.getElementById('saveAllBtn');
  const loadBtn = document.getElementById('loadAllBtn');
  const fileInp = document.getElementById('loadFileInput');

if(saveBtn){
  saveBtn.addEventListener('click', ()=>{
    try{
      // Ask the user for a name (default from current fileName or a timestamped suggestion)
      const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
      const suggested = (App.state.fileName ? App.state.fileName.replace(/\.td2$/i,'') : `Signal-Plan-${ts}`);
      const nameInput = prompt('Enter a file name (no extension):', suggested);
      if(nameInput === null){
        setStatus('Save cancelled.');
        return;
      }
      const finalName = ensureTD2(nameInput);

      const data = buildExportObject();
      const text = makeHumanReadableText(data);
      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = finalName;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);

      // Remember & display the filename
      App.state.fileName = finalName;
      setFileNameLabel(App.state.fileName);
      setStatus('💾 Saved: ' + finalName);
    }catch(err){
      console.error(err);
      setStatus('❌ Save failed: ' + (err && err.message ? err.message : err));
    }
  });
}

  // Duplicate saveBtn click handler removed

  if(loadBtn && fileInp){
    loadBtn.addEventListener('click', ()=> fileInp.click());
    fileInp.addEventListener('change', async ()=>{
      const f = fileInp.files && fileInp.files[0];
      if(!f){ setStatus('No file selected.'); return; }
      try{
        const text = await f.text();
        const obj  = parseHumanReadableText(text);

        // Apply main settings
        if(obj.main){
          if(typeof obj.main.mainCycle === 'number'){
            App.state.mainCycle = obj.main.mainCycle;
            const mc = document.getElementById('mainCycle'); if(mc) mc.value = App.state.mainCycle;
          }
          if(typeof obj.main.viewCycles === 'number'){
            App.state.viewCycles = obj.main.viewCycles;
            const vc = document.getElementById('viewCycles'); if(vc) vc.value = String(App.state.viewCycles);
          }
        }

        // Apply junctions
        if(Array.isArray(obj.junctions)){
          App.state.junctions = obj.junctions.map(j=>({
            id: j.id,
            name: j.name,
            doubleCycle: !!j.doubleCycle,
            travelPrev: j.travelPrev|0,
            travelNext: j.travelNext|0,
            stages: (j.stages||[]).map(s=>({ label: s.label, minGreenSec: s.minGreenSec|0 })),
            intergreen: (j.intergreen||[]).map(row => row.slice()),
            utcPlan: (j.utcPlan||[]).map(r => ({ to: r.to, at: r.at|0 }))
          }));
        }

        // Apply overlays and uncommitted adjustments
        App.state._overlays = Array.isArray(obj.overlays) ? obj.overlays.slice() : [];
        App.state.temp = obj.temp ? {
          offsets:  {...(obj.temp.offsets  || {})},
          boundary: {...(obj.temp.boundary || {})}
        } : { offsets:{}, boundary:{} };

        // Refresh UI
        rebuildTabs();
        setDirty();
        runValidation({silent:true});
        if(App.state.readyToPlot && App.state.validOk){ drawHidden(); drawLabels(); }
        setStatus('📂 Loaded data from file.');
        App.state.fileName = (f && f.name) ? f.name : App.state.fileName;
        setFileNameLabel(App.state.fileName);
      }catch(err){
        console.error(err);
        setStatus('❌ Load failed: ' + (err && err.message ? err.message : err));
        alert('Load failed: ' + (err && err.message ? err.message : err));
      }finally{
        fileInp.value = '';
      }
    });
  }

  document.getElementById('validateBtn').addEventListener('click', ()=>{ runValidation({silent:false}); });
  document.getElementById('plotBtn').addEventListener('click', ()=>{
    if(!App.state.validOk){ alert('Please Validate first.'); return; }
    App.state.readyToPlot = true;
    const p=document.getElementById('plotBtn'); 
    if(p) p.classList.remove('dirty');
    setStatus('Plotted ✓');
    log('Plot clicked — drawing (viewport-fixed)','info');

    // Initial default view: choose px/s so [C, C*N] fills viewport exactly
    const Cj = App.state.mainCycle; 
    const N = App.state.viewCycles || 2;
    const viewportPx = measureViewportPx();
    App.state.pxPerSec = Math.max(1, Math.round(viewportPx / Math.max(1, N*Cj)));
    const zoom = document.getElementById('zoom');
    if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
    setViewStart(Cj);
    // ✅ Enable the Plot tab after first successful plot
    const plotTabBtn = document.getElementById('tabPlotBtn');
    if (plotTabBtn) plotTabBtn.disabled = false;

    drawHidden();
    drawLabels();
  });
  // (transferBtn block removed)

  const zoom = document.getElementById('zoom');
  if(zoom){
    const zmin = 1, zmax = 12; // slider range
    // initialise slider position from pxPerSec -> slider value (invert mapping)
    zoom.value = String(zmax - (App.state.pxPerSec - zmin));
    zoom.addEventListener('input', ()=>{
      const C = document.getElementById('hiddenCanvas');
      const oldPps = App.state.pxPerSec||4;
      const centerSec = App.state.viewStartSec + (C.width/oldPps)/2;
      const val = Math.max(zmin, Math.min(zmax, parseInt(zoom.value,10) || zmin));
      App.state.pxPerSec = Math.max(1, (zmax - val) + zmin); // LEFT = bigger spacing
      const newViewDur = C.width / App.state.pxPerSec;
      setViewStart(centerSec - newViewDur/2);
      drawHidden();
      drawLabels();
    });
  }
  const fit = document.getElementById('fitBtn');
  if(fit){ fit.addEventListener('click', ()=>{
    const Cj = App.state.mainCycle; const N = App.state.viewCycles || 2;
    const viewportPx = measureViewportPx();
    const pps = Math.max(1, Math.floor(viewportPx / Math.max(1, N*Cj)));
    App.state.pxPerSec = pps;
    if(zoom){ const zmin=1,zmax=12; zoom.value = String(zmax - (App.state.pxPerSec - zmin)); }
    const centerSec = 1*Cj + (N*Cj)/2; // focus cycles 1..N
    setViewStart(centerSec - (viewportPx/pps)/2);
    drawHidden(); drawLabels();
  }); }
  // Copy combined label+timeline canvas to clipboard
  const copyBtn = document.getElementById('copyBtn');
  if(copyBtn){
    copyBtn.addEventListener('click', async ()=>{
      try{
        const label = document.getElementById('labelCanvas');
        const plot  = document.getElementById('hiddenCanvas');
        if(!(label && plot)) throw new Error('Canvas not ready');
        // Ensure latest drawing
        if(App.state.readyToPlot && App.state.validOk){ drawHidden(); drawLabels(); }

        // Compose a single canvas
        const w = (label.width|0) + (plot.width|0);
        const h = Math.max(label.height|0, plot.height|0);
        const off = document.createElement('canvas');
        off.width = w; off.height = h;
        const octx = off.getContext('2d');
        // white background so it looks good in dark clipboards
        octx.fillStyle = '#fff'; octx.fillRect(0,0,w,h);
        // draw label gutter then plot
        octx.drawImage(label, 0, 0);
        octx.drawImage(plot,  label.width|0, 0);

        // Helper: convert dataURL to Blob without fetch() (Safari/Firefox robustness)
        function dataURLtoBlob(dataURL){
          const parts = dataURL.split(',');
          const mime = (parts[0].match(/:(.*?);/)||[])[1] || 'image/png';
          const bstr = atob(parts[1]);
          let n = bstr.length;
          const u8 = new Uint8Array(n);
          while(n--){ u8[n] = bstr.charCodeAt(n); }
          return new Blob([u8], {type:mime});
        }

        async function saveAsDownload(blob){
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'td-diagram.png';
          document.body.appendChild(a); a.click(); a.remove();
          URL.revokeObjectURL(url);
        }

        async function tryClipboard(blob){
          // Check feature support; some browsers (Safari/Firefox) may not support image writes.
          const canWrite = !!(navigator.clipboard && window.ClipboardItem);
          if(!canWrite) return false;
          try{
            const item = new ClipboardItem({ [blob.type || 'image/png']: blob });
            await navigator.clipboard.write([item]);
            log('TD Diagram copied to clipboard (PNG)', 'info');
            // Set status chip after successful copy
            setStatus('✅ Diagram copied to clipboard.');
            return true;
          }catch(err){
            console.warn('Clipboard write failed, falling back to download:', err && err.name ? err.name : err);
            return false;
          }
        }

        const handleBlob = async (blob)=>{
          if(!blob) throw new Error('toBlob failed');
          const ok = await tryClipboard(blob);
          if(!ok){
            await saveAsDownload(blob);
            // Set status chip after download
            setStatus('📁 Diagram downloaded as PNG.');
            alert('Clipboard not available — downloaded PNG instead.');
          }
        };

        if(off.toBlob){
          off.toBlob(async (blob)=>{
            try{ await handleBlob(blob); }
            catch(err){ console.error(err); alert('Copy failed: '+(err && err.message ? err.message : err)); }
          }, 'image/png');
        }else{
          // Older Safari fallback via dataURL (no fetch to avoid platform issues)
          const dataURL = off.toDataURL('image/png');
          try{
            const blob = dataURLtoBlob(dataURL);
            await handleBlob(blob);
          }catch(err){ console.error(err); alert('Copy failed: '+(err && err.message ? err.message : err)); }
        }
      }catch(err){
        console.error(err);
        alert('Copy failed: ' + (err && err.message ? err.message : err));
      }
    });
  }
  // Add scroll event to timelineScroll to keep labels synced
  const scroller = document.getElementById('timelineScroll');
  if(scroller){
    scroller.addEventListener('wheel', (e)=>{
      e.preventDefault(); // keep the page still
      const scale = (e.shiftKey ? 0.25 : 1); // Shift for finer pan
      const delta = (Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY) * scale;
      const secDelta = delta / (App.state.pxPerSec||1);
      setViewStart(App.state.viewStartSec + secDelta);
      drawHidden();
    }, {passive:false});
  }

  // --- Adjust modal wiring ---
  (function(){
    const btn = document.getElementById('adjustBtn');

    let wired = false; // modal wired after first open
    // element refs
    let modal, closeBtn, applyBtn, clearBtn, clearAllBtn, commitBtn, selJ, off, listBox;

    function getBoxB(){ return document.getElementById('adjBoundaries'); }

    function fillJ(){
      selJ = document.getElementById('adjJunc');
      if(!selJ) return;
      const juncs = App.state.junctions||[]; selJ.innerHTML='';
      juncs.forEach((j)=>{ const o=document.createElement('option'); o.value=j.id; o.textContent=j.name; selJ.appendChild(o); });
    }
    function renderB(){
      const boxB = getBoxB(); if(!boxB) return;
      const sel = document.getElementById('adjJunc');
      const j = (App.state.junctions||[]).find(x=>x.id=== (sel && sel.value));
      if(!j){ boxB.innerHTML=''; return; }
      const plan = getAdjustedPlan(j);
      const list = plan.map(p=>p.to);
      const bmap = (App.state.temp.boundary[j.id]||{});
      let html = '<table class="grid"><thead><tr><th>Boundary</th><th>Δ (s)</th></tr></thead><tbody>';
      for(let i=0;i<list.length;i++){
        const cur = list[i]; const nxt = list[(i+1)%list.length];
        const key = String(i);
        const val = (typeof bmap[key]==='number') ? bmap[key] : 0;
        html += `<tr><td>${cur} → ${nxt}</td><td><input type="number" step="1" value="${val}" data-bidx="${key}"></td></tr>`;
      }
      html += '</tbody></table>';
      boxB.innerHTML = html;
    }
function readDraftAdjustments(){
  const out = [];
  const id = (document.getElementById('adjJunc')||{}).value;
  if(!id) return out;

  const offInp = document.getElementById('adjOffset');
  const offVal = parseInt(offInp && offInp.value || '0', 10) || 0;
  if(offVal) out.push({ kind:'offset', id, value: offVal });

  const boxB = document.getElementById('adjBoundaries');
  if(boxB){
    boxB.querySelectorAll('input[data-bidx]').forEach(inp=>{
      const v = parseInt(inp.value||'0',10) || 0;
      if(v) out.push({ kind:'boundary', id, bidx: inp.getAttribute('data-bidx'), value: v });
    });
  }
  return out;
}
function renderAdjustList(){
  if(!listBox) listBox = document.getElementById('adjList');
  const sel = document.getElementById('adjJunc');
  const j = (App.state.junctions||[]).find(x=>x.id=== (sel && sel.value));
  if(!listBox || !j){ if(listBox) listBox.innerHTML=''; return; }

  const plan = getAdjustedPlan(j);
  const labels = plan.map(p=>p.to);

  const rows = readDraftAdjustments().map(a=>{
    if(a.kind==='offset'){
      return `<tr>
        <td>Offset</td>
        <td>${a.value>0?('+'+a.value):a.value}s</td>
        <td style="white-space:nowrap">
          <button data-edit-adj="offset">Edit</button>
          <button data-del-adj="offset">Delete</button>
        </td>
      </tr>`;
    }else{
      const i = parseInt(a.bidx,10) || 0;
      const cur = labels[i] || `S${i+1}`;
      const nxt = labels[(i+1)%labels.length] || `S${(i+1)%labels.length+1}`;
      return `<tr>
        <td>${cur} → ${nxt}</td>
        <td>${a.value>0?('+'+a.value):a.value}s</td>
        <td style="white-space:nowrap">
          <button data-edit-adj="${i}">Edit</button>
          <button data-del-adj="${i}">Delete</button>
        </td>
      </tr>`;
    }
  }).join('');

  listBox.innerHTML = rows
    ? `<table class="grid compact auto"><thead><tr><th>Adjustment</th><th>Δ (s)</th><th>Actions</th></tr></thead><tbody>${rows}</tbody></table>`
    : '<div class="muted" style="font-size:12px">No adjustments yet.</div>';
}
    function wireModalElements(){
      modal    = document.getElementById('adjModal');
      closeBtn = document.getElementById('adjCloseBtn');
      applyBtn = document.getElementById('adjApply');
      clearBtn = document.getElementById('adjClear');
      selJ     = document.getElementById('adjJunc');
      off      = document.getElementById('adjOffset');
      clearAllBtn = document.getElementById('adjClearAll');
      listBox = document.getElementById('adjList');
      commitBtn = document.getElementById('adjCommit');

if(listBox){
  listBox.addEventListener('click', (ev)=>{
    const editKey = ev.target && ev.target.getAttribute && ev.target.getAttribute('data-edit-adj');
    const delKey  = ev.target && ev.target.getAttribute && ev.target.getAttribute('data-del-adj');

    if(editKey != null){
      if(editKey === 'offset'){
        const offInp = document.getElementById('adjOffset');
        if(offInp){ offInp.focus(); offInp.select && offInp.select(); }
      }else{
        const bidx = String(parseInt(editKey,10));
        const boxB = document.getElementById('adjBoundaries');
        if(boxB){
          const target = boxB.querySelector(`input[data-bidx="${bidx}"]`);
          if(target){ target.focus(); target.select && target.select(); }
        }
      }
      return; // don't fall through to delete
    }

    if(delKey != null){
      if(delKey === 'offset'){
        const offInp = document.getElementById('adjOffset');
        if(offInp){ offInp.value = '0'; }
        renderAdjustList();
        setStatus('Adjustment removed.');
      }else{
        const bidx = String(parseInt(delKey,10));
        const boxB = document.getElementById('adjBoundaries');
        if(boxB){
          const target = boxB.querySelector(`input[data-bidx="${bidx}"]`);
          if(target){ target.value = '0'; }
        }
        renderAdjustList();
        setStatus('Adjustment removed.');
      }
    }
  });
}

if(clearAllBtn){
  clearAllBtn.addEventListener('click', ()=>{
    const offInp = document.getElementById('adjOffset');
    if(offInp) offInp.value = '0';
    const boxB = document.getElementById('adjBoundaries');
    if(boxB){ boxB.querySelectorAll('input[data-bidx]').forEach(inp => inp.value = '0'); }
    renderAdjustList();
    setStatus('All adjustments cleared.');
  });
}


      if(!modal || wired) return !!modal;

      if(closeBtn) closeBtn.addEventListener('click', close);
      if(modal) modal.addEventListener('click', (e)=>{ if(e.target===modal) close(); });
      if(selJ) selJ.addEventListener('change', ()=>{
        const id = selJ.value; const v = (App.state.temp.offsets[id]||0); const offInp = document.getElementById('adjOffset'); if(offInp) offInp.value=String(v);
        renderB();
      renderAdjustList();
      });
    
    
      if(applyBtn) applyBtn.addEventListener('click', ()=>{
        const id = (document.getElementById('adjJunc')||{}).value; if(!id) return;
        const offInp = document.getElementById('adjOffset');
        App.state.temp.offsets[id] = parseInt(offInp && offInp.value || 0,10) || 0;
        const boxB = getBoxB(); if(boxB){
          App.state.temp.boundary[id] = App.state.temp.boundary[id] || {};
          boxB.querySelectorAll('input[data-bidx]').forEach(inp=>{
            const k = inp.getAttribute('data-bidx');
            const v = parseInt(inp.value||0,10) || 0;
            App.state.temp.boundary[id][k] = v;
          });
        }
        if(App.state.readyToPlot && App.state.validOk){ drawHidden(); }
        setStatus('Adjustments applied.');
        close();
      });
      if(clearBtn) clearBtn.addEventListener('click', ()=>{
        const id = (document.getElementById('adjJunc')||{}).value; if(!id) return;
        if(App.state.temp.offsets) delete App.state.temp.offsets[id];
        if(App.state.temp.boundary) delete App.state.temp.boundary[id];
        const offInp = document.getElementById('adjOffset'); if(offInp) offInp.value='0';
        renderB();
        renderAdjustList();
        if(App.state.readyToPlot && App.state.validOk){ drawHidden(); }
        setStatus('Adjustments cleared for this junction.');
      });

      if(commitBtn){
  commitBtn.addEventListener('click', ()=>{
    try{
      // Apply current temporary adjustments to ALL junctions' UTC plans
      (App.state.junctions||[]).forEach((j)=>{
        // Build adjusted plan using current offsets/boundary tweaks
        const adj = getAdjustedPlan(j);

        // Persist adjusted times back into the real plan (whole seconds)
        j.utcPlan = adj.map(r=>({ to: r.to, at: Math.round(r.at) }));

        // Clear temporary adjustments for this junction
        if(App.state.temp && App.state.temp.offsets)  delete App.state.temp.offsets[j.id];
        if(App.state.temp && App.state.temp.boundary) delete App.state.temp.boundary[j.id];
      });

      // Refresh UI and mark data as changed (forces re-Validate)
      rebuildTabs();
      setDirty();

      // Redraw plot if already plotted
      if(App.state.readyToPlot && App.state.validOk){
        drawHidden();
        drawLabels();
      }

      // Update status bar + refresh the modal’s lists
      setStatus('UTC plans updated from adjustments.');
      close();
      renderB();
      renderAdjustList();
    }catch(err){
  console.error(err);
  setStatus('❌ Update failed: ' + (err && err.message ? err.message : err));
}
    
    
  
  });
}

      wired = true;
      return true;
    }

    function open(){
      if(!wireModalElements()) return;
      fillJ();
      if(selJ && !selJ.value && selJ.options.length){ selJ.value = selJ.options[0].value; }
      const id = selJ ? selJ.value : null;
      const offInp = document.getElementById('adjOffset');
      if(offInp) offInp.value = String((id && App.state.temp.offsets[id]) || 0);
      renderB();
      renderAdjustList();
      const m = document.getElementById('adjModal');
      if(m){ m.classList.add('show'); m.setAttribute('aria-hidden','false'); }
      if(m){ enableDragModal('adjModal'); }
    }
    function close(){ const m=document.getElementById('adjModal'); if(m){ m.classList.remove('show'); m.setAttribute('aria-hidden','true'); } }

    if(btn) btn.addEventListener('click', open);
  })();
  // --- Overlays modal wiring ---
  (function(){
    const btn = document.getElementById('overlayBtn');

    // Modal-scoped refs are lazily assigned when the modal is first opened
    let modalWired = false;
    let editingIndex = -1; // -1 => creating, >=0 => editing existing overlay

    // element refs (assigned in wireModalElements)
    let modal, closeBtn, cancelBtn, saveBtn, selFrom, selTo, modeSel, s, e, col, a, selStage, stageGroup, timeGroup, listBox;

    function updateModeVisibility(){
      if(!modeSel || !stageGroup || !timeGroup) return;
      const m = (modeSel && modeSel.value) || 'stage';
      stageGroup.style.display = (m==='stage') ? '' : 'none';
      timeGroup.style.display  = (m==='time')  ? '' : 'none';
    }

    function populateStages(){
      if(!selStage || !selFrom) return;
      selStage.innerHTML='';
      const fromIdx = parseInt(selFrom && selFrom.value || '0',10) || 0;
      const J = (App.state.junctions||[])[fromIdx];
      const stages = (J && Array.isArray(J.stages)) ? J.stages : [];
      stages.forEach(st=>{
        const opt=document.createElement('option');
        opt.value = st.label;       // value is stage label
        opt.textContent = st.label; // display label
        selStage.appendChild(opt);
      });
    }

    function populateJunctions(){
      const juncs = (App.state.junctions||[]);
      function fillJ(sel){
        if(!sel) return; sel.innerHTML='';
        juncs.forEach((j,idx)=>{
          const opt=document.createElement('option');
          opt.value=String(idx);
          opt.textContent=j.name; // show junction name
          sel.appendChild(opt);
        });
      }
      fillJ(selFrom); fillJ(selTo);
      if(selTo && selFrom && selTo.options.length>1){
        selTo.selectedIndex = Math.min(selFrom.selectedIndex+1, selTo.options.length-1);
      }
      populateStages();
      updateModeVisibility();
    }

    function prefillOverlayForm(ovl){
      try{
        if(!ovl) return;
        if(selFrom){ selFrom.value = String(ovl.from||0); }
        if(selTo){   selTo.value   = String(ovl.to||0); }
        populateStages();
        if(modeSel){ modeSel.value = ovl.mode || 'stage'; }
        updateModeVisibility();
        if((ovl.mode||'stage') === 'stage'){
          if(selStage && ovl.stage){ selStage.value = ovl.stage; }
        }else{
          if(s){ s.value = String(Math.max(0, ovl.start||0)); }
          if(e){ e.value = String(Math.max(0, ovl.end||0)); }
        }
        if(col){ col.value = ovl.color || '#ffa500'; }
        if(a){ a.value = String(typeof ovl.alpha==='number' ? ovl.alpha : 0.3); }
      }catch(_){/* ignore */}
    }

    function renderOverlayList(){
      const box = document.getElementById('ovlList');
      if(!box) return;
      const list = Array.isArray(App.state._overlays) ? App.state._overlays : [];
      if(list.length === 0){
        box.innerHTML = '<div class="muted" style="font-size:12px">No overlays yet.</div>';
        return;
      }
      const juncs = App.state.junctions||[];
      const rows = list.map((o,idx)=>{
        const jf = juncs[o.from] ? juncs[o.from].name : ('J'+o.from);
        const jt = juncs[o.to]   ? juncs[o.to].name   : ('J'+o.to);
        const mode = o.mode || 'stage';
        const detail = (mode==='stage') ? (o.stage || '—') : `${o.start||0}–${o.end||0}s`;
        const swatch = `<span style="display:inline-block;width:10px;height:10px;background:${o.color||'#ffa500'};border:1px solid #ccc;border-radius:2px;vertical-align:middle;margin-right:6px"></span>`;
        return `<tr>
          <td style="text-align:left">${swatch}${jf} → ${jt}</td>
          <td>${mode}</td>
          <td>${detail}</td>
          <td style="white-space:nowrap">
            <button data-edit-ovl="${idx}">Edit</button>
            <button data-del-ovl="${idx}">Delete</button>
          </td>
        </tr>`;
      }).join('');
      box.innerHTML = `<table class="grid"><thead><tr><th>Route</th><th>Mode</th><th>Stage / Time</th><th>Actions</th></tr></thead><tbody>${rows}</tbody></table>
        <div style="margin-top:8px;display:flex;justify-content:flex-end"><button data-clear-all>Clear all</button></div>`;
    }

    function wireModalElements(){
      if(modalWired) return true;
      // query elements now that modal exists in DOM
      modal     = document.getElementById('ovlModal');
      closeBtn  = document.getElementById('ovlCloseBtn');
      cancelBtn = document.getElementById('ovlCancel');
      saveBtn   = document.getElementById('ovlSave');
      selFrom   = document.getElementById('ovlFrom');
      selTo     = document.getElementById('ovlTo');
      modeSel   = document.getElementById('ovlMode');
      s         = document.getElementById('ovlStart');
      e         = document.getElementById('ovlEnd');
      col       = document.getElementById('ovlColor');
      a         = document.getElementById('ovlAlpha');
      selStage  = document.getElementById('ovlStage');
      stageGroup= document.getElementById('stageGroup');
      timeGroup = document.getElementById('timeGroup');
      listBox   = document.getElementById('ovlList');

// Quick colour presets click handler
(function(){
  const quick = document.getElementById('ovlColorQuick');
  if(!quick) return;
  quick.addEventListener('click', (ev)=>{
    const btn = ev.target.closest && ev.target.closest('.swatch-btn');
    if(!btn) return;
    const v = btn.getAttribute('data-color');
    if(v && col){
      col.value = v;
    }
  });
})();

      if(!modal) return false;

      if(modeSel){ modeSel.addEventListener('change', updateModeVisibility); }
      if(selFrom){ selFrom.addEventListener('change', populateStages); }

      if(listBox){
        listBox.addEventListener('click', (ev)=>{
          const editIdx = ev.target && ev.target.getAttribute && ev.target.getAttribute('data-edit-ovl');
          if(editIdx!=null){
            const i = parseInt(editIdx,10);
            if(Array.isArray(App.state._overlays) && i>=0 && i < App.state._overlays.length){
              editingIndex = i;
              if(saveBtn) saveBtn.textContent = 'Update overlay';
              if(!modal.classList.contains('show')){
                modal.classList.add('show');
                modal.setAttribute('aria-hidden','false');
              }
              populateJunctions();
              prefillOverlayForm(App.state._overlays[i]);
            }
            return; // don't fall through
          }
          const delIdx = ev.target && ev.target.getAttribute && ev.target.getAttribute('data-del-ovl');
          if(delIdx!=null){
            const i = parseInt(delIdx,10);
            if(Array.isArray(App.state._overlays) && i>=0 && i < App.state._overlays.length){
              App.state._overlays.splice(i,1);
              renderOverlayList();
              if(App.state.readyToPlot && App.state.validOk){ drawHidden(); }
            setStatus('Overlay deleted.');
            }
          }
          
          if(ev.target && ev.target.hasAttribute && ev.target.hasAttribute('data-clear-all')){
            if(Array.isArray(App.state._overlays) && App.state._overlays.length){
              App.state._overlays.length = 0;
              renderOverlayList();
              if(App.state.readyToPlot && App.state.validOk){ drawHidden(); }
              setStatus('All overlays cleared.');
            }
          }
        });
      }

      if(closeBtn){ closeBtn.addEventListener('click', closeModal); }
      if(cancelBtn){ cancelBtn.addEventListener('click', closeModal); }
      if(modal){ modal.addEventListener('click', (ev)=>{ if(ev.target===modal) closeModal(); }); }

      // Save / Update overlay
      if(saveBtn){
        saveBtn.addEventListener('click', ()=>{
          try{
            App.state._overlays = App.state._overlays || [];
            const mode = (modeSel && modeSel.value) || 'stage';
            const ovl = {
              from: parseInt(selFrom.value||'0',10) || 0,
              to:   parseInt(selTo.value||'0',10)   || 0,
              mode,
              color: (col && col.value) || '#ffa500',
              alpha: Math.max(0, Math.min(1, parseFloat((a && a.value) || '0.3') || 0.3))
            };
            if(mode === 'stage'){
              ovl.stage = (selStage && selStage.value) || null;
            }else{
              ovl.start = Math.max(0, parseFloat((s && s.value) || '0') || 0);
              ovl.end   = Math.max(ovl.start, Math.max(0, parseFloat((e && e.value) || '0') || 0));
            }

            if(editingIndex >= 0){
              App.state._overlays[editingIndex] = ovl;
              setStatus('Overlay updated.');
            }else{
              App.state._overlays.push(ovl);
              setStatus('Overlay saved.');
            }

            renderOverlayList();
            if(App.state.readyToPlot && App.state.validOk){ drawHidden(); }
            closeModal();
          }catch(err){
            console.error(err);
            setStatus('❌ Save overlay failed: ' + (err && err.message ? err.message : err));
          }
        });
      }

      // Escape to close (query modal each time to avoid stale refs)
      document.addEventListener('keydown', (ev)=>{ const m=document.getElementById('ovlModal'); if(ev.key==='Escape' && m && m.classList.contains('show')) closeModal(); });

      modalWired = true;
      return true;
    }

    function openModal(){
      editingIndex = -1;
      if(!modalWired){ if(!wireModalElements()) return; }
      if(saveBtn) saveBtn.textContent = 'Save overlay';
      populateJunctions();
      renderOverlayList();
      modal.classList.add('show');
      modal.setAttribute('aria-hidden','false');
      enableDragModal('ovlModal');
    }

    function closeModal(){
      editingIndex = -1;
      if(saveBtn) saveBtn.textContent = 'Save overlay';
      const m = document.getElementById('ovlModal');
      if(m){ m.classList.remove('show'); m.setAttribute('aria-hidden','true'); }
    }

    if(btn){ btn.addEventListener('click', openModal); }
  })();
}
boot();
// === Drag-to-pan (pointer drag on the timeline) ===
(function addDragPan(){
  const area = document.getElementById('timelineScroll');
  if(!area) return;
  let dragging = false, startX = 0, startV0 = 0;

  area.addEventListener('pointerdown', (e)=>{
    dragging = true;
    startX = e.clientX;
    startV0 = App.state.viewStartSec;
    try{ area.setPointerCapture(e.pointerId); }catch(_){/* noop */}
  });
  area.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx = e.clientX - startX;
    const secDelta = -dx / (App.state.pxPerSec || 1);
    setViewStart(startV0 + secDelta);
    drawHidden();
  });
  ['pointerup','pointercancel','pointerleave'].forEach(type=>{
    area.addEventListener(type, ()=>{
      dragging = false;
    });
  });
})();

// === Arrow keys to pan (Shift for fine pan) ===
(function addKeyPan(){
  function stepSec(){
    const C = document.getElementById('hiddenCanvas');
    const px = (C && C.width) || 600;
    return Math.max(1, Math.round((px / (App.state.pxPerSec||1)) * 0.1));
  }
  document.addEventListener('keydown', (e)=>{
    if(document.activeElement && ['INPUT','SELECT','TEXTAREA'].includes(document.activeElement.tagName)) return;
    if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
      e.preventDefault();
      const fine = e.shiftKey ? 0.25 : 1;
      const deltaSec = stepSec() * (e.key==='ArrowLeft' ? -1 : 1) * fine;
      setViewStart(App.state.viewStartSec + deltaSec);
      drawHidden();
    }
  });
})();

// === Redraw on window resize (keep viewport width in sync) ===
(function addResizeRedraw(){
  let t=null;
  window.addEventListener('resize', ()=>{
    clearTimeout(t);
    t = setTimeout(()=>{
      const vp = measureViewportPx();
      if(App.state.readyToPlot && App.state.validOk){
        drawHidden();
        drawLabels();
      }else{
        // Before first plot: choose px/s so [C, C*N] fits the viewport
        const Cj = App.state.mainCycle; const N = App.state.viewCycles || 2;
        if(Cj){
          const vp2 = measureViewportPx();
          if(vp2>0){
            App.state.pxPerSec = Math.max(1, vp2 / Math.max(1, N*Cj));
            setViewStart(Cj);
            const zoom = document.getElementById('zoom');
            if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
          }
        }
      }
    }, 120);
  });
})();

// === Pinch/Trackpad zoom with pointer anchor ===
(function addWheelPinchZoom(){
  const area = document.getElementById('timelineScroll');
  if(!area) return;
  const zoomSlider = document.getElementById('zoom');
  const zmin = 1, zmax = 12;

  area.addEventListener('wheel', (e)=>{
    if(!e.ctrlKey) return; // only treat ctrl+wheel as zoom (trackpad pinch)
    e.preventDefault();
    const rect = area.getBoundingClientRect();
    const oldPps = App.state.pxPerSec || 4;
    const x = e.clientX - rect.left;              // px from left edge in viewport
    const anchorSec = App.state.viewStartSec + (x / oldPps);

    // deltaY > 0 => zoom out; < 0 => zoom in. Pick a gentle factor.
    const factor = Math.exp(-e.deltaY * 0.0015);
    let newPps = oldPps * factor;
    newPps = Math.max(1, Math.min(200, newPps)); // clamp sane range
    App.state.pxPerSec = newPps;

    // Keep the same timeline second under the pointer after zoom
    const newV0 = anchorSec - (x / newPps);
    setViewStart(newV0);

    // Sync slider (inverted mapping)
    if(zoomSlider){ zoomSlider.value = String(zmax - (Math.round(App.state.pxPerSec) - zmin)); }

    drawHidden();
    drawLabels();
  }, {passive:false});
})();

// === Touch pinch-to-zoom (two fingers) with midpoint anchor ===
(function addTouchPinchZoom(){
  const area = document.getElementById('timelineScroll');
  if(!area) return;
  const zoomSlider = document.getElementById('zoom');
  const zmin = 1, zmax = 12;
  let tracking = false;
  let startDist = 0;
  let startPps = 0;
  let anchorX = 0; // viewport px from left
  let anchorSec = 0;

  function getTouches(e){ return e.touches ? Array.from(e.touches) : []; }
  function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
  function mid(a,b){ return { x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2 }; }

  area.addEventListener('touchstart', (e)=>{
    const ts = getTouches(e);
    if(ts.length===2){
      const rect = area.getBoundingClientRect();
      startDist = dist(ts[0], ts[1]);
      startPps = App.state.pxPerSec || 4;
      const m = mid(ts[0], ts[1]);
      anchorX = m.x - rect.left;
      anchorSec = App.state.viewStartSec + (anchorX / startPps);
      tracking = true;
      e.preventDefault();
    }
  }, {passive:false});

  area.addEventListener('touchmove', (e)=>{
    if(!tracking) return;
    const ts = getTouches(e);
    if(ts.length!==2){ tracking=false; return; }
    const d = dist(ts[0], ts[1]);
    if(startDist <= 0) return;
    const factor = d / startDist; // >1 zoom in, <1 zoom out
    let newPps = startPps * factor;
    newPps = Math.max(1, Math.min(200, newPps));
    App.state.pxPerSec = newPps;

    const newV0 = anchorSec - (anchorX / newPps);
    setViewStart(newV0);

    if(zoomSlider){ zoomSlider.value = String(zmax - (Math.round(App.state.pxPerSec) - zmin)); }
    drawHidden();
    drawLabels();
    e.preventDefault();
  }, {passive:false});

  area.addEventListener('touchend', ()=>{ tracking=false; }, {passive:true});
  area.addEventListener('touchcancel', ()=>{ tracking=false; }, {passive:true});
})();

// === iOS Safari gesture events fallback (gesturestart/gesturechange/gestureend) ===
(function addWebkitGestureZoom(){
  const area = document.getElementById('timelineScroll');
  if(!area) return;
  const zoomSlider = document.getElementById('zoom');
  const zmin = 1, zmax = 12;
  let startPps = 0;
  let anchorX = 0; // px from left in the viewport
  let anchorSec = 0;

  function clampPps(v){ return Math.max(1, Math.min(200, v)); }

  area.addEventListener('gesturestart', (e)=>{
    // Prevent page zoom and initialize anchor under gesture center
    e.preventDefault();
    const rect = area.getBoundingClientRect();
    startPps = App.state.pxPerSec || 4;
    // Safari provides clientX/clientY as the gesture center
    anchorX = (typeof e.clientX === 'number' ? (e.clientX - rect.left) : (rect.width/2));
    anchorSec = App.state.viewStartSec + (anchorX / startPps);
  }, {passive:false});

  area.addEventListener('gesturechange', (e)=>{
    e.preventDefault();
    const newPps = clampPps(startPps * (e.scale || 1));
    App.state.pxPerSec = newPps;
    const newV0 = anchorSec - (anchorX / newPps);
    setViewStart(newV0);
    if(zoomSlider){ zoomSlider.value = String(zmax - (Math.round(App.state.pxPerSec) - zmin)); }
    drawHidden();
    drawLabels();
  }, {passive:false});

  area.addEventListener('gestureend', (e)=>{
    // no-op; keep final zoom
    if(e && e.preventDefault) e.preventDefault();
  }, {passive:false});
})();
</script>

<script>
// Master Data / Plot / Debug tab handling..
(function(){
function el(id){ return document.getElementById(id); }

function setActive(btnId){
  ['tabDataBtn','tabPlotBtn','tabDebugBtn'].forEach(id=>{
    const btn = el(id);
    if(btn){ btn.classList.toggle('active', id===btnId); }
  });
}

function showPanel(which){
  // hide all
  const dataCard = el('bootAlert') && el('bootAlert').parentElement;
  if(dataCard) dataCard.style.display='none';
  const plot = el('plotPanel'); if(plot){ plot.style.display='none'; plot.setAttribute('aria-hidden','true'); }
  const dbg  = el('debugPanel'); if(dbg){ dbg.style.display='none'; dbg.setAttribute('aria-hidden','true'); }

  // show requested
  if(which==='data'){
    setActive('tabDataBtn');
    if(dataCard) dataCard.style.display='';
  }else if(which==='plot'){
    setActive('tabPlotBtn');
    if(plot){ plot.style.display=''; plot.setAttribute('aria-hidden','false'); }
    // After becoming visible, measure and redraw on next frame to avoid blurry oversize canvas
    requestAnimationFrame(()=>{
      if(typeof drawLabels === 'function') drawLabels();
      if(typeof drawHidden === 'function' && App.state && App.state.validOk && App.state.readyToPlot){
        drawHidden();
        // One-shot auto-fit on first time Plot becomes visible after plotting
        if(!App.state.didAutoFit){
          const Cj = App.state.mainCycle; const N = App.state.viewCycles || 2;
          const viewportPx = measureViewportPx();
          if(viewportPx > 0 && Cj){
            // choose px/s so [C, C*N] fills the viewport exactly and set left edge at C
            App.state.pxPerSec = Math.max(1, viewportPx / Math.max(1, N*Cj));
            setViewStart(Cj);
            const zoom = document.getElementById('zoom');
            if(zoom){ const zmin=1,zmax=12; zoom.value = String(Math.max(zmin, Math.min(zmax, zmax - (Math.round(App.state.pxPerSec) - zmin)))); }
            drawHidden();
            drawLabels();
            App.state.didAutoFit = true;
          }
        }
      }
    });
  }else if(which==='debug'){
    setActive('tabDebugBtn');
    if(dbg){ dbg.style.display=''; dbg.setAttribute('aria-hidden','false'); }
  }
}

// Expose showPanel for boot-time use
window.__showPanel = showPanel;

document.addEventListener('DOMContentLoaded', ()=>{
  el('tabDataBtn')  && el('tabDataBtn').addEventListener('click', ()=> showPanel('data'));
  el('tabPlotBtn')  && el('tabPlotBtn').addEventListener('click', ()=> showPanel('plot'));
  el('tabDebugBtn') && el('tabDebugBtn').addEventListener('click', ()=> showPanel('debug'));
  // initial state
  showPanel('data');
});
})();
</script>

<!-- Adjust modal (temporary) -->
<div id="adjModal" class="modal-backdrop" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal-card" role="document" aria-labelledby="adjTitle">
    <header>
      <h3 id="adjTitle">Adjust junction</h3>
      <button id="adjCloseBtn" aria-label="Close">✕</button>
    </header>
    <div class="body">
      <div class="modal-grid">
        <label>Junction
          <select id="adjJunc"></select>
        </label>
        <label>Offset (s)
          <input type="number" id="adjOffset" step="1" value="0"/>
        </label>
      </div>
 <h4 style="margin:10px 0 6px 0;font-size:13px">Vary by moving boundaries</h4>
<div id="adjBoundaries"></div>

<hr style="border:none;border-top:1px solid var(--line);margin:10px 0"/>
<h4 style="margin:0 0 6px 0;font-size:13px">Current adjustments</h4>
<div id="adjList"></div>

<p class="muted" style="margin-top:8px;font-size:12px">
  Offset shifts the UTC plan for this junction. Boundary deltas move the change points (e.g., between S1 → S2).
  These are temporary and only affect the plot/overlays.
</p>
    </div>
    <footer>
      <button id="adjClear">Clear</button>
      <button id="adjCommit">Update UTC plans</button>
      <button id="adjApply">Apply</button>
    </footer>
  </div>
</div>

<!-- Overlays modal (temporary) -->
<div id="ovlModal" class="modal-backdrop" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal-card" role="document" aria-labelledby="ovlTitle">
    <header>
      <h3 id="ovlTitle">Add overlay</h3>
      <button id="ovlCloseBtn" aria-label="Close">✕</button>
    </header>
    <div class="body">
      <div class="modal-grid">
        <label>From
          <select id="ovlFrom"></select>
        </label>
        <label>To
          <select id="ovlTo"></select>
        </label>
        <label>Mode
  <select id="ovlMode">
    <option value="stage" selected>Stage-based</option>
    <option value="time">Time-based</option>
  </select>
</label>
<div id="stageGroup">
  <label>Stage (origin)
    <select id="ovlStage"></select>
  </label>
</div>
<div id="timeGroup" style="display:none">
  <label>Start (s)
    <input type="number" id="ovlStart" min="0" step="1" value="0"/>
  </label>
  <label>End (s)
    <input type="number" id="ovlEnd" min="0" step="1" value="10"/>
  </label>
</div>      
  <div>
  <div class="swatch-row" id="ovlColorQuick" aria-label="Quick colours">
    <button type="button" class="swatch-btn" data-color="#e74c3c" title="Red"></button>
    <button type="button" class="swatch-btn" data-color="#3498db" title="Blue"></button>
    <button type="button" class="swatch-btn" data-color="#27ae60" title="Green"></button>
    <button type="button" class="swatch-btn" data-color="#ffa500" title="Orange"></button>
    <button type="button" class="swatch-btn" data-color="#9b59b6" title="Purple"></button>
  </div>
  <label>Color
    <input type="color" id="ovlColor" value="#ffa500"/>
  </label>
</div>      
        
        
        <label>Opacity (0–1)
          <input type="number" id="ovlAlpha" min="0" max="1" step="0.05" value="0.3"/>
        </label>
      </div>
      <hr style="border:none;border-top:1px solid var(--line);margin:10px 0"/>
      <h4 style="margin:0 0 6px 0;font-size:13px">Current overlays</h4>
      <div id="ovlList"></div>
      <p class="muted" style="margin-top:8px;font-size:12px">
        This is a temporary overlay editor. Saving stores to memory only; drawing integration comes next.
      </p>
    </div>
    <footer>
      <button id="ovlCancel">Cancel</button>
      <button id="ovlSave">Save overlay</button>
    </footer>
  </div>
</div>

  
    
      
      
    
     
<script type="application/json" id="initCfg">
{
  "appName": "Signal Plan Checker",
  "ui": { "debug": { "enabled": true, "dock": { "showOnLoad": true }, "logLevel": "info", "validationOnActions": false, "perfMarkers": true } },
  "mainCycleTime": { "default": 60, "min": 1, "max": 240, "mustBeEvenWhenAnyDouble": true },
  "junctionCount": { "default": 3, "min": 2, "max": 5 },
  "doubleCycle": { "allowed": true, "requireAtLeastOneMainCycle": true },
  "stageCount": { "default": 2, "min": 2 },
  "stage": { "minGreen": { "default": 7, "min": 1 } },
  "intergreen": { "diagonalLockedValue": -1, "allowNotPermittedValue": -1, "defaults": { "offDiagonal": 5 }, "domain": { "min": 0, "max": 60 } },
  "journeyTime": { "default": 20, "min": 0, "max": 60 },
  "utcPlan": { "requireAtLeastOneChange": true, "markRequestsBlue": true, "showQueuedChangeMarkers": true, "warnOnDelay": true, "alertOnMissedChange": true, "defaults": [ { "to": "S1", "at": 0 }, { "to": "S2", "at": 30 } ] },
  "plot": { "hiddenWindowMultiplier": 5, "viewCycles": { "options": [1, 2, 3], "default": 2 }, "grid10s": true, "ticks1s": true, "ticks5s": true, "rowHeight": 48, "rowGap": 18, "leftMargin": 120, "topMargin": 24, "pxPerSec": 4 },
  "overlays": { "adjacentOnly": true, "defaultOpacity": 0.8, "shadeAlpha": 0.15, "repeatByCycle": true, "allowCustomIntervals": true },
  "packaging": { "includeDocs": true }
}
</script>
</body>
</html>