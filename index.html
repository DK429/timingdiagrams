<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Signal Plan Checker v1.1.0-alpha</title>
<style>
:root{--bg:#ffffff;--card:#f8f9fb;--line:#e8e8e8;--ink:#222;--muted:#666;--brand:#0a66ff}
*{box-sizing:border-box}
html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
header{padding:14px 16px;border-bottom:1px solid var(--line);background:#fafafa}
h1{font-size:18px;margin:0}
small.muted{color:var(--muted)}
main{padding:12px}
.row{display:flex;gap:12px;flex-wrap:wrap}
.card{background:var(--card);border:1px solid var(--line);border-radius:10px;padding:10px}
#controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
label{display:flex;flex-direction:column;font-size:12px;gap:4px}
input[type=number], select{padding:6px 8px;border:1px solid #d6d6d6;border-radius:6px;min-width:70px}
.tabs{display:flex;gap:6px;margin-top:10px;flex-wrap:wrap}
.tab{padding:8px 10px;border:1px solid var(--line);border-bottom:none;border-radius:8px 8px 0 0;background:#f1f3f6;cursor:pointer}
.tab.active{background:#fff}
.tabpanel{display:none;border:1px solid var(--line);border-radius:0 10px 10px 10px;padding:10px;background:#fff}
.tabpanel.active{display:block}
.grid{border-collapse:collapse;width:100%}
.grid th,.grid td{border:1px solid #eee;padding:6px 8px;font-size:12px;text-align:center}
.grid th{background:#f7f7f7}
.sr{font-size:12px;color:var(--muted)}
button{padding:8px 10px;border:1px solid #d0d0d0;border-radius:8px;background:#f7f7f7;cursor:pointer}
#plot{border:1px solid var(--line);border-radius:8px;height:480px;background:#fff;display:flex;align-items:center;justify-content:center;color:#999}
#debugDock{position:fixed;left:10px;right:10px;bottom:10px;max-height:38vh;overflow:auto;background:#0d1117;color:#c9d1d9;
border:1px solid #30363d;border-radius:10px;padding:8px;font-family:ui-monospace,Consolas,Monaco,monospace;z-index:9999}
#debugDock .row{align-items:center}
.logline.info{color:#a5d6ff} .logline.warn{color:#ffd27f} .logline.err{color:#ffb4b4}
</style>
</head>
<body>
<header>
  <h1>Signal Plan Checker <small class="muted">v1.1.0-alpha</small></h1>
  <div class="sr">Simplification: global cycle + double, per-junction tabs, intergreen matrix, adjacent travel, init-configurable</div>
</header>

<main>
  <section class="card">
    <div id="controls">
      <label>Init file
        <input id="initFile" type="file" accept="application/json"/>
      </label>
      <label>Main cycle (s)
        <input id="mainCycle" type="number" min="1" max="240" value="60"/>
      </label>
      <label>Junctions
        <input id="jCount" type="number" min="2" max="5" value="3"/>
      </label>
      <label>View cycles
        <select id="viewCycles">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
        </select>
      </label>
      <button id="validateBtn">Validate</button>
      <button id="plotBtn">Plot</button>
    </div>
  </section>

  <section class="card">
    <div class="tabs" id="jtabs"></div>
    <div id="tabpanels"></div>
  </section>

  <section class="card">
    <div id="plot">Plot renderer coming next step (hidden-canvas window + copy-to-visible)</div>
  </section>
</main>

<div id="debugDock" style="display:none">
  <div class="row">
    <button id="dbgClear">Clear</button>
    <span>Debug log</span>
  </div>
  <div id="log"></div>
</div>

<script>
function log(msg, level){ try{const box=document.getElementById('log'); if(!box) return;
  const d=document.createElement('div'); d.className='logline '+(level||'info'); d.textContent='['+new Date().toLocaleTimeString()+'] '+msg;
  box.appendChild(d); box.scrollTop=box.scrollHeight;}catch(e){} }
window.addEventListener('error', e=>log('ERROR: '+(e.message||e.error),'err'));
window.addEventListener('unhandledrejection', e=>log('PROMISE: '+(e.reason&&e.reason.message?e.reason.message:e.reason),'err'));

const App = { initCfg:null, state:null };

async function loadBundledInit(){
  try{
    const res = await fetch('init.config.json',{cache:'no-store'});
    if(!res.ok) throw new Error('init.config.json not found');
    return await res.json();
  }catch(e){
    log('Bundled init missing — using hard defaults','warn');
    return null;
  }
}
function hardDefaults(){
  return {"appName": "Signal Plan Checker", "ui": {"debug": {"enabled": true, "dock": {"showOnLoad": true}, "logLevel": "info", "validationOnActions": true, "perfMarkers": true}}, "mainCycleTime": {"default": 60, "min": 1, "max": 240, "mustBeEvenWhenAnyDouble": true}, "junctionCount": {"default": 3, "min": 2, "max": 5}, "doubleCycle": {"allowed": true, "requireAtLeastOneMainCycle": true}, "stageCount": {"default": 2, "min": 2}, "stage": {"minGreen": {"default": 7, "min": 1}, "duration": {"min": 1}}, "intergreen": {"diagonalLockedValue": -1, "allowNotPermittedValue": -1, "defaults": {"offDiagonal": 5}, "domain": {"min": 0, "max": 60}}, "journeyTime": {"default": 20, "min": 0, "max": 60}, "utcPlan": {"requireAtLeastOneChange": true, "markRequestsBlue": true, "warnOnDelay": true, "alertOnMissedChange": true}, "plot": {"hiddenWindowMultiplier": 5, "viewCycles": {"options": [1, 2, 3], "default": 2}, "grid10s": true, "ticks1s": true, "ticks5s": true}, "overlays": {"adjacentOnly": true, "defaultOpacity": 0.8, "shadeAlpha": 0.15, "repeatByCycle": true, "allowCustomIntervals": true}, "packaging": {"includeDocs": true}};
}

function mkJunction(id, cfg){
  const nStages = Math.max(cfg.stageCount.min, cfg.stageCount.default);
  const stages = []; const minG = cfg.stage.minGreen.default;
  for(let i=0;i<nStages;i++){
    stages.push({ label: id+(i+1), minGreenSec: minG, durationSec: Math.max(cfg.stage.duration.min, minG) });
  }
  const N = nStages; const ig = [];
  for(let r=0;r<N;r++){
    const row=[];
    for(let c=0;c<N;c++){
      row.push(r===c ? cfg.intergreen.diagonalLockedValue : cfg.intergreen.defaults.offDiagonal);
    }
    ig.push(row);
  }
  return {
    id, name: 'Junction '+id,
    doubleCycle: false,
    utcPlan: [],
    stages, intergreen: ig,
    travelPrev: cfg.journeyTime.default, travelNext: cfg.journeyTime.default
  };
}

function buildState(cfg){
  const count = Math.max(cfg.junctionCount.min, Math.min(cfg.junctionCount.max, cfg.junctionCount.default));
  const ids = ['A','B','C','D','E'].slice(0,count);
  const juncs = ids.map(id=>mkJunction(id, cfg));
  return {
    mainCycle: Math.max(cfg.mainCycleTime.min, Math.min(cfg.mainCycleTime.max, cfg.mainCycleTime.default)),
    viewCycles: (cfg.plot.viewCycles && cfg.plot.viewCycles.default)||2,
    junctions: juncs
  };
}

function rebuildTabs(){
  const tabs = document.getElementById('jtabs');
  const panels = document.getElementById('tabpanels');
  tabs.innerHTML=''; panels.innerHTML='';
  App.state.junctions.forEach((j, idx)=>{
    const t=document.createElement('button'); t.className='tab'+(idx===0?' active':''); t.textContent=j.name; t.dataset.id=j.id;
    t.addEventListener('click', ()=>{ document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active')); t.classList.add('active');
      document.querySelectorAll('.tabpanel').forEach(p=>p.classList.remove('active')); document.getElementById('tp_'+j.id).classList.add('active'); });
    tabs.appendChild(t);

    const tp=document.createElement('div'); tp.id='tp_'+j.id; tp.className='tabpanel'+(idx===0?' active':'');
    tp.innerHTML = renderJunctionPanel(j);
    panels.appendChild(tp);
  });
  wirePanelInputs();
}

function renderJunctionPanel(j){
  const cfg = App.initCfg;
  const N = j.stages.length;
  let rows = '';
  for(let i=0;i<N;i++){
    rows += `<tr>
      <td><input data-t="stageLabel" data-id="${j.id}" data-idx="${i}" value="${j.stages[i].label}"></td>
      <td><input type="number" min="${cfg.stage.minGreen.min}" value="${j.stages[i].minGreenSec}" data-t="minGreen" data-id="${j.id}" data-idx="${i}"></td>
      <td><input type="number" min="${cfg.stage.duration.min}" value="${j.stages[i].durationSec}" data-t="duration" data-id="${j.id}" data-idx="${i}"></td>
    </tr>`;
  }
  let ig = '<table class="grid"><thead><tr><th>From \\ To</th>';
  for(let c=0;c<N;c++){ ig += `<th>${j.stages[c].label}</th>`; }
  ig += '</tr></thead><tbody>';
  for(let r=0;r<N;r++){
    ig += `<tr><th>${j.stages[r].label}</th>`;
    for(let c=0;c<N;c++){
      if(r===c){ ig += `<td><input value="${cfg.intergreen.diagonalLockedValue}" disabled></td>`; }
      else{ ig += `<td><input type="number" step="1" min="-1" max="${cfg.intergreen.domain.max}" value="${j.intergreen[r][c]}" data-t="ig" data-id="${j.id}" data-r="${r}" data-c="${c}"></td>`; }
    }
    ig += '</tr>';
  }
  ig += '</tbody></table>';

  const upLbl = `To previous (↑)`;
  const dnLbl = `To next (↓)`;
  return `
    <div class="row">
      <label>Double cycle <input type="checkbox" data-t="double" data-id="${j.id}" ${j.doubleCycle?'checked':''}></label>
      <label>${upLbl}<input type="number" min="${App.initCfg.journeyTime.min}" max="${App.initCfg.journeyTime.max}" value="${j.travelPrev}" data-t="travelPrev" data-id="${j.id}"></label>
      <label>${dnLbl}<input type="number" min="${App.initCfg.journeyTime.min}" max="${App.initCfg.journeyTime.max}" value="${j.travelNext}" data-t="travelNext" data-id="${j.id}"></label>
      <label>Stage count<input type="number" min="${App.initCfg.stageCount.min}" max="8" value="${j.stages.length}" data-t="stageCount" data-id="${j.id}"></label>
    </div>
    <h4>Stages</h4>
    <table class="grid">
      <thead><tr><th>Label</th><th>Min green (s)</th><th>Duration (s)</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
    <h4>Intergreen matrix (leading intergreen; -1 = not permitted)</h4>
    ${ig}
    <div class="sr">UTC change list UI to be added next step</div>
  `;
}

function wirePanelInputs(){
  document.querySelectorAll('[data-t]').forEach(inp=>{
    inp.addEventListener('change', onPanelChange);
    inp.addEventListener('blur', onPanelChange);
  });
}
function findJ(id){ return App.state.junctions.find(x=>x.id===id); }

function onPanelChange(e){
  const t=e.target.getAttribute('data-t'); const id=e.target.getAttribute('data-id');
  const j=findJ(id); if(!j) return;
  if(t==='double'){ j.doubleCycle = e.target.checked; }
  if(t==='travelPrev'){ j.travelPrev = clampInt(e.target.value, App.initCfg.journeyTime.min, App.initCfg.journeyTime.max); e.target.value=j.travelPrev; }
  if(t==='travelNext'){ j.travelNext = clampInt(e.target.value, App.initCfg.journeyTime.min, App.initCfg.journeyTime.max); e.target.value=j.travelNext; }
  if(t==='stageCount'){
    const n = Math.max(App.initCfg.stageCount.min, Math.min(8, parseInt(e.target.value||2,10)));
    resizeStages(j, n);
    rebuildTabs();
  }
  if(t==='stageLabel'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].label = e.target.value|| (j.id+(idx+1)); rebuildTabs(); }
  if(t==='minGreen'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].minGreenSec = Math.max(App.initCfg.stage.minGreen.min, parseInt(e.target.value||App.initCfg.stage.minGreen.default,10)); e.target.value=j.stages[idx].minGreenSec; }
  if(t==='duration'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].durationSec = Math.max(App.initCfg.stage.duration.min, parseInt(e.target.value||App.initCfg.stage.minGreen.default,10)); e.target.value=j.stages[idx].durationSec; }
  if(t==='ig'){ const r=parseInt(e.target.getAttribute('data-r'),10), c=parseInt(e.target.getAttribute('data-c'),10);
    let v = parseInt(e.target.value||0,10); if(v!==-1) v = Math.max(App.initCfg.intergreen.domain.min, Math.min(App.initCfg.intergreen.domain.max, v));
    j.intergreen[r][c] = v; e.target.value = v; }
  if(App.initCfg.ui.debug.validationOnActions){ runValidation(); }
}

function resizeStages(j, n){
  const minG = App.initCfg.stage.minGreen.default;
  while(j.stages.length < n){ j.stages.push({label: j.id+(j.stages.length+1), minGreenSec: minG, durationSec: Math.max(App.initCfg.stage.duration.min, minG)}); }
  while(j.stages.length > n){ j.stages.pop(); }
  const N = j.stages.length;
  const igNew = [];
  for(let r=0;r<N;r++){
    const row=[];
    for(let c=0;c<N;c++){
      if(r===c) row.push(App.initCfg.intergreen.diagonalLockedValue);
      else{
        const v = (j.intergreen[r] and typeof j.intergreen[r][c] === 'number') ? j.intergreen[r][c] : App.initCfg.intergreen.defaults.offDiagonal;
        row.push(v);
      }
    }
    igNew.push(row);
  }
  j.intergreen = igNew;
}

function clampInt(v, lo, hi){ v=parseInt(v||0,10); if(isNaN(v)) v=0; return Math.max(lo, Math.min(hi, v)); }

function effectiveCycle(j){ return j.doubleCycle ? (App.state.mainCycle/2) : App.state.mainCycle; }

function validateJunction(j){
  const errs=[];
  j.stages.forEach((s)=>{
    if(!(Number.isInteger(s.minGreenSec) || typeof s.minGreenSec==='number')) errs.push(`${j.name}: Stage ${s.label} minGreen not a number`);
    if(!(Number.isInteger(s.durationSec) || typeof s.durationSec==='number')) errs.push(`${j.name}: Stage ${s.label} duration not a number`);
    if(s.minGreenSec < App.initCfg.stage.minGreen.min) errs.push(`${j.name}: Stage ${s.label} minGreen < ${App.initCfg.stage.minGreen.min}`);
    if(s.durationSec < s.minGreenSec) errs.push(`${j.name}: Stage ${s.label} duration (${s.durationSec}) < minGreen (${s.minGreenSec})`);
  });
  const N=j.stages.length;
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const v = j.intergreen[r][c];
      if(r===c && v!==App.initCfg.intergreen.diagonalLockedValue) errs.push(`${j.name}: IG ${j.stages[r].label}→${j.stages[c].label} diagonal must be ${App.initCfg.intergreen.diagonalLockedValue}`);
      if(r!==c){
        if(!Number.isInteger(v)) errs.push(`${j.name}: IG ${j.stages[r].label}→${j.stages[c].label} must be integer or -1`);
        if(v<-1) errs.push(`${j.name}: IG ${j.stages[r].label}→${j.stages[c].label} < -1 invalid`);
        if(v>App.initCfg.intergreen.domain.max) errs.push(`${j.name}: IG ${j.stages[r].label}→${j.stages[c].label} > max ${App.initCfg.intergreen.domain.max}`);
      }
    }
  }
  if(j.travelPrev<App.initCfg.journeyTime.min || j.travelPrev>App.initCfg.journeyTime.max) errs.push(`${j.name}: Travel ↑ out of range (0..${App.initCfg.journeyTime.max})`);
  if(j.travelNext<App.initCfg.journeyTime.min || j.travelNext>App.initCfg.journeyTime.max) errs.push(`${j.name}: Travel ↓ out of range (0..${App.initCfg.journeyTime.max})`);
  return errs;
}

function runValidation(){
  const errs=[];
  const anyDouble = App.state.junctions.some(j=>j.doubleCycle);
  if(anyDouble && (App.state.mainCycle % 2 !== 0)){ errs.push(`Main cycle must be even when any junction is double-cycling.`); }
  const anyMain = App.state.junctions.some(j=>!j.doubleCycle);
  if(!anyMain){ errs.push(`At least one junction must run the main cycle (not double).`); }
  App.state.junctions.forEach(j=>errs.push(...validateJunction(j)));
  const ok = errs.length===0;
  log(ok? 'VALIDATION OK' : ('VALIDATION: '+errs.join(' | ')), ok?'info':'warn');
  if(!ok) alert('Fix these first:\n - '+errs.join('\n - '));
  return ok;
}

async function boot(){
  const bundled = await loadBundledInit();
  App.initCfg = bundled || hardDefaults();
  const dock = document.getElementById('debugDock');
  dock.style.display = (App.initCfg.ui && App.initCfg.ui.debug && App.initCfg.ui.debug.enabled && App.initCfg.ui.debug.dock.showOnLoad) ? 'block' : 'none';
  document.getElementById('dbgClear').addEventListener('click', ()=>{ document.getElementById('log').textContent=''; });

  App.state = buildState(App.initCfg);
  document.getElementById('mainCycle').value = App.state.mainCycle;
  document.getElementById('jCount').value = App.state.junctions.length;
  document.getElementById('viewCycles').value = String(App.state.viewCycles);

  rebuildTabs();
  log('Loaded init + built default state','info');

  document.getElementById('initFile').addEventListener('change', async (e)=>{
    const f=e.target.files && e.target.files[0]; if(!f) return;
    try{
      const text = await f.text(); const cfg = JSON.parse(text);
      App.initCfg = cfg;
      log('Custom init loaded — rebuilding','info');
      App.state = buildState(App.initCfg);
      document.getElementById('mainCycle').value = App.state.mainCycle;
      document.getElementById('jCount').value = App.state.junctions.length;
      document.getElementById('viewCycles').value = String(App.state.viewCycles);
      rebuildTabs();
    }catch(err){ log('Init load error: '+(err.message||err),'err'); alert('Invalid init file'); }
  });
  document.getElementById('mainCycle').addEventListener('change', (e)=>{
    const v = parseInt(e.target.value||60,10);
    const clamped = Math.max(App.initCfg.mainCycleTime.min, Math.min(App.initCfg.mainCycleTime.max, v));
    App.state.mainCycle = clamped; e.target.value=clamped;
    if(App.initCfg.ui.debug.validationOnActions) runValidation();
  });
  document.getElementById('jCount').addEventListener('change', (e)=>{
    const v = parseInt(e.target.value||3,10);
    const c = Math.max(App.initCfg.junctionCount.min, Math.min(App.initCfg.junctionCount.max, v));
    const cur = App.state.junctions.length;
    if(c>cur){
      const ids=['A','B','C','D','E'];
      for(let i=cur;i<c;i++){ App.state.junctions.push(mkJunction(ids[i], App.initCfg)); }
    }else if(c<cur){
      App.state.junctions.splice(c);
    }
    e.target.value=c;
    rebuildTabs();
    if(App.initCfg.ui.debug.validationOnActions) runValidation();
  });
  document.getElementById('viewCycles').addEventListener('change', (e)=>{ App.state.viewCycles = parseInt(e.target.value||2,10); });

  document.getElementById('validateBtn').addEventListener('click', runValidation);
  document.getElementById('plotBtn').addEventListener('click', ()=>{
    if(!runValidation()) return;
    document.getElementById('plot').textContent = 'Renderer pending (will draw '+App.state.viewCycles+' cycle(s) from t='+App.state.mainCycle+'s)';
    log('Plot requested — renderer stub called','info');
  });
}

boot();
</script>
</body>
</html>
