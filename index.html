<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Signal Plan Checker 1.1.7-alpha</title>
<style>
:root{--bg:#ffffff;--card:#f8f9fb;--line:#e8e8e8;--ink:#222;--muted:#666;--accent:#0a66ff;--errbg:#fff4f4;--errbd:#f5c2c7;--errink:#842029}
*{box-sizing:border-box} html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;height:100%}
header{padding:14px 16px;border-bottom:1px solid var(--line);background:#fafafa}
h1{font-size:18px;margin:0} small.muted{color:var(--muted)}
main{height:calc(100vh - 60px);display:grid;grid-template-rows:auto 1fr;gap:10px;padding:10px}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
.card{background:var(--card);border:1px solid var(--line);border-radius:10px;padding:10px}
.alert{display:none;margin:8px 0;padding:10px 12px;border:1px solid var(--errbd);background:var(--errbg);color:var(--errink);border-radius:8px}
.alert.show{display:block}
.tabs{display:flex;gap:6px;margin-top:6px;flex-wrap:wrap}
.tab{padding:8px 10px;border:1px solid var(--line);border-bottom:none;border-radius:8px 8px 0 0;background:#f1f3f6;cursor:pointer}
.tab.active{background:#fff}
.tabpanel{display:none;border:1px solid var(--line);border-radius:0 10px 10px 10px;padding:10px;background:#fff;max-height:40vh;overflow:auto}
.tabpanel.active{display:block}
.grid{border-collapse:collapse;width:100%} .grid th,.grid td{border:1px solid #eee;padding:6px 8px;font-size:12px;text-align:center} .grid th{background:#f7f7f7}
button{padding:8px 10px;border:1px solid #d0d0d0;border-radius:8px;background:#f7f7f7;cursor:pointer;transition:box-shadow .15s,border-color .15s}
button.dirty{border-color:var(--accent); box-shadow: 0 0 0 3px rgba(10,102,255,.15)}
button:disabled{opacity:.55; cursor:not-allowed}
label{display:flex;flex-direction:column;font-size:12px;gap:4px}
input[type=number], select{padding:6px 8px;border:1px solid #d6d6d6;border-radius:6px;min-width:70px}
.badge{padding:2px 6px;border-radius:6px;background:#eef1ff;border:1px solid #dbe1ff;font-size:12px}
#plotPanel{display:grid;grid-template-rows:auto 1fr;gap:8px;height:100%}
#plotToolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
#hiddenWrap{border:1px dashed #bbb;border-radius:8px;background:#fff;overflow:auto;position:relative}
#hiddenCanvas{display:block;image-rendering:crisp-edges}
#visibleWrap{border:1px solid #bbb;border-radius:8px;background:#fff;overflow:auto;position:relative}
#visibleCanvas{display:block;image-rendering:crisp-edges}
#debugDock{position:fixed;left:10px;right:10px;bottom:10px;max-height:38vh;overflow:auto;background:#0d1117;color:#c9d1d9;
border:1px solid #30363d;border-radius:10px;padding:8px;font-family:ui-monospace,Consolas,Monaco,monospace;z-index:9999}
.logline.info{color:#a5d6ff} .logline.warn{color:#ffd27f} .logline.err{color:#ffb4b4}
.infochip{padding:4px 8px;border-radius:999px;border:1px solid #e0e0e0;background:#fff;font-size:12px}
#twoCols{display:grid;grid-template-columns:1fr 1fr;gap:10px;height:100%}
</style>
</head>
<body>
<div id="masterTabs" class="tabbar" style="display:flex;gap:6px;padding:8px;border-bottom:1px solid #ddd;position:sticky;top:0;background:#fafafa;z-index:10">
  <button class="tabbtn" data-tab="data"    style="padding:8px 12px;border:1px solid #ccc;border-bottom:none;border-radius:8px 8px 0 0;background:#fff;cursor:pointer">Data</button>
  <button class="tabbtn" data-tab="hidden"  style="padding:8px 12px;border:1px solid #ccc;border-bottom:none;border-radius:8px 8px 0 0;background:#eee;cursor:pointer">Hidden ext canvas</button>
</div>
<div id="tabPanels">
  <section id="tab-data" style="display:block;"></section>
  <section id="tab-hidden" style="display:none; height: calc(100vh - 48px); overflow:auto; padding:8px;"></section>
</div>

<header>
  <h1>Signal Plan Checker <small class="muted">1.1.7-alpha</small></h1>
  <div class="row"><span class="badge">Min-green + queued (hidden)</span><span class="badge">Transfer-ready visible canvas</span></div>
</header>

<main>
  <section class="card">
    <div id="bootAlert" class="alert"></div>
    <div class="row">
      <span class="badge">Init auto-loaded</span>
      <label>Main cycle (s)<input id="mainCycle" type="number" min="1" max="240" value="60"/></label>
      <label>Junctions<input id="jCount" type="number" min="2" max="5" value="3"/></label>
      <label>View cycles
        <select id="viewCycles">
          <option value="1">1</option><option value="2" selected>2</option><option value="3">3</option>
        </select>
      </label>
      <button id="validateBtn">Validate</button>
      <button id="plotBtn" disabled>Plot</button>
      <button id="transferBtn" disabled>Transfer to Visible</button>
      <span id="statusChip" class="infochip">Waiting for Validate…</span>
    </div>
    <div class="tabs" id="jtabs"></div>
    <div id="tabpanels"></div>
  </section>

  <section id="plotPanel" class="card">
    <div id="plotToolbar">
      <strong>Hidden Extended Canvas (dev)</strong>
      <label>Zoom (px/s)<input type="range" id="zoom" min="1" max="12" step="1" value="4"/></label>
      <button id="fitBtn">Fit</button>
      <span id="info" class="badge">—</span>
    </div>
    <div id="twoCols">
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
          <strong>Hidden</strong><span class="badge">full horizon</span>
        </div>
        <div id="hiddenWrap">
          <canvas id="hiddenCanvas"></canvas>
        </div>
      </div>
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
          <strong>Visible</strong><span class="badge">window: cycles 1..(1+N)</span>
        </div>
        <div id="visibleWrap">
          <canvas id="visibleCanvas"></canvas>
        </div>
      </div>
    </div>
  </section>
</main>

<div id="debugDock" style="display:none">
  <div class="row">
    <button id="dbgClear">Clear</button>
    <span>Debug log</span>
  </div>
  <div id="log"></div>
</div>

<script>
const App = { initCfg:null, state:{ validOk:false, readyToPlot:false, pxPerSec:4 } };

function setDirty(){
  const v=document.getElementById('validateBtn');
  const p=document.getElementById('plotBtn');
  const x=document.getElementById('transferBtn');
  if(v) v.classList.add('dirty');
  if(p){ p.classList.add('dirty'); p.disabled = true; }
  if(x){ x.disabled = true; }
  App.state.validOk=false;
  App.state.readyToPlot=false;
  const chip=document.getElementById('statusChip');
  if(chip) chip.textContent='Changes detected — Validate required';
}

function log(msg, level){
  try{
    const box=document.getElementById('log'); if(!box) return;
    const d=document.createElement('div'); d.className='logline '+(level||'info'); d.textContent='['+new Date().toLocaleTimeString()+'] '+msg;
    box.appendChild(d); box.scrollTop=box.scrollHeight;
  }catch(e){}
}
window.addEventListener('error', e=>log('ERROR: '+(e.message||e.error),'err'));
window.addEventListener('unhandledrejection', e=>log('PROMISE: '+(e.reason&&e.reason.message?e.reason.message:e.reason),'err'));

async function loadBundledInit(){
  try{
    const res = await fetch('init.config.json',{cache:'no-store'});
    if(!res.ok) throw new Error('init.config.json not found');
    return await res.json();
  }catch(e){
    return {"appName": "Signal Plan Checker", "ui": {"debug": {"enabled": true, "dock": {"showOnLoad": true}, "logLevel": "info", "validationOnActions": false, "perfMarkers": true}}, "mainCycleTime": {"default": 60, "min": 1, "max": 240, "mustBeEvenWhenAnyDouble": true}, "junctionCount": {"default": 3, "min": 2, "max": 5}, "doubleCycle": {"allowed": true, "requireAtLeastOneMainCycle": true}, "stageCount": {"default": 2, "min": 2}, "stage": {"minGreen": {"default": 7, "min": 1}}, "intergreen": {"diagonalLockedValue": -1, "allowNotPermittedValue": -1, "defaults": {"offDiagonal": 5}, "domain": {"min": 0, "max": 60}}, "journeyTime": {"default": 20, "min": 0, "max": 60}, "utcPlan": {"requireAtLeastOneChange": true, "markRequestsBlue": true, "showQueuedChangeMarkers": true, "warnOnDelay": true, "alertOnMissedChange": true, "defaults": [{"to": "S1", "at": 0}, {"to": "S2", "at": 30}]}, "plot": {"hiddenWindowMultiplier": 5, "viewCycles": {"options": [1, 2, 3], "default": 2}, "grid10s": true, "ticks1s": true, "ticks5s": true, "rowHeight": 48, "rowGap": 18, "leftMargin": 120, "topMargin": 24, "pxPerSec": 4}, "overlays": {"adjacentOnly": true, "defaultOpacity": 0.8, "shadeAlpha": 0.15, "repeatByCycle": true, "allowCustomIntervals": true}, "packaging": {"includeDocs": true}};
  }
}

function mkDefaultUTCPlan(cfg){
  return (cfg.utcPlan && Array.isArray(cfg.utcPlan.defaults)) ? JSON.parse(JSON.stringify(cfg.utcPlan.defaults)) : [{to:'S1',at:0},{to:'S2',at:30}];
}

function mkJunction(id, cfg){
  const nStages = Math.max(cfg.stageCount.min, cfg.stageCount.default);
  const stages = []; const minG = cfg.stage.minGreen.default;
  for(let i=0;i<nStages;i++){ stages.push({ label: 'S'+(i+1), minGreenSec: minG }); }
  const N = nStages; const ig = [];
  for(let r=0;r<N;r++){ const row=[]; for(let c=0;c<N;c++){ row.push(r===c ? cfg.intergreen.diagonalLockedValue : cfg.intergreen.defaults.offDiagonal); } ig.push(row); }
  return { id, name:'Junction '+id, doubleCycle:false, utcPlan: mkDefaultUTCPlan(cfg), stages, intergreen: ig, travelPrev: cfg.journeyTime.default, travelNext: cfg.journeyTime.default };
}

function buildState(cfg){
  const count = Math.max(cfg.junctionCount.min, Math.min(cfg.junctionCount.max, cfg.junctionCount.default));
  const ids = ['A','B','C','D','E'].slice(0,count);
  const juncs = ids.map(id=>mkJunction(id, cfg));
  return { ...App.state, mainCycle: Math.max(cfg.mainCycleTime.min, Math.min(cfg.mainCycleTime.max, cfg.mainCycleTime.default)), viewCycles: (cfg.plot.viewCycles && cfg.plot.viewCycles.default)||2, junctions: juncs, pxPerSec: cfg.plot.pxPerSec||4 };
}

function effectiveCycle(j){ return j.doubleCycle ? (App.state.mainCycle/2) : App.state.mainCycle; }
function stageIndex(j, label){ const idx = j.stages.findIndex(s=>s.label===label); return (idx>=0? idx : 0); }
function clampInt(v, lo, hi){ v=parseInt(v||0,10); if(isNaN(v)) v=0; return Math.max(lo, Math.min(hi, v)); }

// ---- min-green realised times (from v1.1.6-alpha) ----
function computeRealisedCycle(j){
  const Cj = effectiveCycle(j);
  const plan = (j.utcPlan||[]).slice().sort((a,b)=>a.at-b.at);
  const N = plan.length;
  if(N===0) return {ok:false, err:['UTC plan empty']};
  const toIdx = plan.map(p=>stageIndex(j,p.to));
  for(let i=0;i<N;i++){
    const from = toIdx[i];
    const to = toIdx[(i+1)%N];
    if(j.intergreen[from][to] === -1){
      const a=j.stages[from].label, b=j.stages[to].label;
      return {ok:false, err:[`${j.name}: Stage move not permitted ${a} → ${b}`]};
    }
  }
  const Rq = new Array(N*2);
  for(let i=0;i<N;i++){ Rq[i]=plan[i].at; }
  for(let i=0;i<N;i++){ Rq[i+N]=plan[i].at + Cj; }
  const RC = new Array(N+1).fill(0);
  RC[0] = Rq[0];
  const details = [];
  for(let i=0;i<N;i++){
    const curIdx = toIdx[i%N];
    const prevIdx = toIdx[(i-1+N)%N];
    const nextIdx = toIdx[(i+1)%N];
    const igPrev = Math.max(0, j.intergreen[prevIdx][curIdx]);
    const mgCur = j.stages[curIdx].minGreenSec|0;
    const nextReq = Rq[i+1];
    const nextNextReq = (i+2<=N) ? Rq[i+2] : (Rq[(i+2)%(N)] + Cj);
    const stageStart = RC[i] + igPrev;
    const earliestMG = stageStart + mgCur;
    const realisedNext = Math.max(nextReq, earliestMG);
    if(realisedNext >= nextNextReq){
      const a = j.stages[curIdx].label, b=j.stages[nextIdx].label;
      return {ok:false, err:[`${j.name}: Stage change not achievable ${a} → ${b} before next request at t=${nextNextReq%Cj}s`]}
    }
    RC[i+1] = realisedNext;
    details.push({i, rqCur:Rq[i], rqNext:nextReq, rqNext2:nextNextReq, igPrev, mgCur, stageStart, earliestMG, realisedNext, delay: realisedNext - nextReq, curStage:j.stages[curIdx].label, nextStage:j.stages[nextIdx].label});
  }
  const RCmod = RC.map(t=> t % Cj);
  return {ok:true, Cj, plan, toIdx, RC, RCmod, details};
}

// ---- validation
function validateJunction(j){
  const errs=[];
  j.stages.forEach((s)=>{
    if(!(Number.isInteger(s.minGreenSec) || typeof s.minGreenSec==='number')) errs.push(`${j.name}: Stage ${s.label} minGreen not a number`);
    if(s.minGreenSec < App.initCfg.stage.minGreen.min) errs.push(`${j.name}: Stage ${s.label} minGreen < ${App.initCfg.stage.minGreen.min}`);
  });
  const Cj = effectiveCycle(j);
  if((j.utcPlan||[]).length===0) errs.push(`${j.name}: UTC plan empty`);
  (j.utcPlan||[]).forEach((p,i)=>{
    if(p.at>=Cj) errs.push(`${j.name}: Plan row #${i+1} at=${p.at} ≥ cycle (${Cj})`);
    if(!j.stages.find(s=>s.label===p.to)) errs.push(`${j.name}: Plan row #${i+1} stage '${p.to}' not found`);
  });
  if(errs.length) return errs;
  const rc = computeRealisedCycle(j);
  if(!rc.ok){ errs.push(...rc.err); }
  return errs;
}

function runValidation({silent}={silent:false}){
  if(!silent) log('Validate clicked','info');
  const errs=[];
  const anyDouble = App.state.junctions.some(j=>j.doubleCycle);
  if(anyDouble && (App.state.mainCycle % 2 !== 0)) errs.push(`Main cycle must be even when any junction is double-cycling.`);
  const anyMain = App.state.junctions.some(j=>!j.doubleCycle);
  if(!anyMain) errs.push(`At least one junction must run the main cycle (not double).`);
  App.state.junctions.forEach(j=>errs.push(...validateJunction(j)));
  const ok = errs.length===0;
  if(ok){
    App.state.validOk = true;
    const v=document.getElementById('validateBtn'); if(v) v.classList.remove('dirty');
    const chip=document.getElementById('statusChip'); if(chip) chip.textContent='Validated ✔ — press Plot to render';
    const plot=document.getElementById('plotBtn'); if(plot) plot.disabled=false;
    const x=document.getElementById('transferBtn'); if(x) x.disabled=false;
    if(!silent) log('VALIDATION OK','info');
    const ba=document.getElementById('bootAlert'); if(ba){ ba.classList.remove('show'); ba.textContent=''; }
  }else{
    App.state.validOk = false;
    const chip=document.getElementById('statusChip'); if(chip) chip.textContent='Validation failed — see alerts';
    const plot=document.getElementById('plotBtn'); if(plot) plot.disabled=true;
    const x=document.getElementById('transferBtn'); if(x) x.disabled=true;
    const msg = 'Fix these first:\n - '+errs.join('\n - ');
    if(silent){
      const ba=document.getElementById('bootAlert'); if(ba){ ba.classList.add('show'); ba.textContent = msg; }
      log('BOOT VALIDATION FAIL: '+errs.join(' | '),'warn');
    }else{
      alert(msg);
      log('VALIDATION FAIL: '+errs.join(' | '),'warn');
    }
  }
  return ok;
}

// ---- drawing hidden
function drawHidden(){
  if(!(App.state.validOk && App.state.readyToPlot)){
    log('Draw suppressed (requires Validate OK + Plot)','warn');
    return;
  }
  const C = document.getElementById('hiddenCanvas'); const ctx = C.getContext('2d');
  const M = App.state.mainCycle; const mult = App.initCfg.plot.hiddenWindowMultiplier || 5; const T = M*mult;
  const pps = App.state.pxPerSec || 4; const left = App.initCfg.plot.leftMargin || 120; const top = App.initCfg.plot.topMargin || 24;
  const rowH = App.initCfg.plot.rowHeight || 48; const gap = App.initCfg.plot.rowGap || 18;
  const width = left + T*pps + 20; const height = top + App.state.junctions.length*(rowH+gap) + 20;
  C.width = width; C.height = height;

  // bg & grid
  ctx.fillStyle="#fff"; ctx.fillRect(0,0,width,height);
  ctx.strokeStyle="#eee"; ctx.lineWidth=1;
  for(let t=0;t<=T;t+=10){ const x=left+t*pps; ctx.beginPath(); ctx.moveTo(x, top-8); ctx.lineTo(x, height-10); ctx.stroke();
    ctx.fillStyle="#999"; ctx.font="10px system-ui"; ctx.fillText(String(t)+'s', x-8, top-12); }

  const greens = ["rgba(60,180,75,0.9)","rgba(90,205,105,0.9)","rgba(120,220,135,0.9)","rgba(150,235,165,0.9)"];

  App.state.junctions.forEach((j, idx)=>{
    const y0 = top + idx*(rowH+gap);
    ctx.fillStyle="#111"; ctx.font="12px system-ui"; ctx.fillText(j.name, 12, y0 + rowH*0.6);
    ctx.strokeStyle="#ddd"; ctx.strokeRect(left, y0, T*pps, rowH);

    const rc = computeRealisedCycle(j);
    if(!rc.ok){
      ctx.fillStyle="#b00020"; ctx.fillText("ERR: "+rc.err.join(' | '), left+8, y0+14);
      log(`DRAW SKIP ${j.name}: `+rc.err.join(' | '),'warn');
      return;
    }
    rc.details.forEach(d=>{
      log(`${j.name} i=${d.i} rq=${Math.round(d.rqNext)} stage=${d.curStage}->${d.nextStage} start=${Math.round(d.stageStart)} MG=${d.mgCur} RC=${Math.round(d.realisedNext)} delay=${Math.round(d.delay)}`,'info');
    });

    const Cj = rc.Cj;
    const cycles = Math.ceil(T / Cj);
    const N = rc.plan.length;

    for(let k=0;k<cycles;k++){
      const base = k*Cj;
      if(App.initCfg.utcPlan.markRequestsBlue){
        ctx.strokeStyle="#4aa1ff"; ctx.lineWidth=2;
        for(let i=0;i<N;i++){
          const rq = rc.plan[i].at;
          const x= left + (base + rq)*pps; ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+rowH); ctx.stroke();
        }
      }
      for(let i=0;i<N;i++){
        const curIdx = rc.toIdx[i];
        const prevIdx = rc.toIdx[(i-1+N)%N];
        const nextIdx = rc.toIdx[(i+1)%N];
        const igPrev = Math.max(0, j.intergreen[prevIdx][curIdx]);
        const RCi = rc.RC[i];
        const RCn = rc.RC[i+1];
        const segStart = (RCi + igPrev) + k*Cj;
        const segEnd = RCn + k*Cj;
        if(segEnd > segStart){
          ctx.fillStyle = greens[curIdx % greens.length];
          ctx.fillRect(left + segStart*pps, y0+6, (segEnd-segStart)*pps, rowH-12);
        }
        const nextReq = rc.details[i].rqNext;
        const delay = rc.details[i].delay;
        if(App.initCfg.utcPlan.showQueuedChangeMarkers && delay>0){
          ctx.strokeStyle="rgba(74,161,255,0.7)";
          ctx.setLineDash([4,3]);
          const x1 = left + (nextReq + k*Cj)*pps;
          const x2 = left + (RCn + k*Cj)*pps;
          ctx.beginPath(); ctx.moveTo(x1, y0+4); ctx.lineTo(x2, y0+4); ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle="rgba(74,161,255,0.9)";
          const triX = x2, triY = y0+4;
          ctx.beginPath(); ctx.moveTo(triX, triY); ctx.lineTo(triX-5, triY-8); ctx.lineTo(triX+5, triY-8); ctx.closePath(); ctx.fill();
        }
        const igNext = Math.max(0, j.intergreen[curIdx][nextIdx]);
        if(igNext>0){
          const igStart = RCn + k*Cj;
          ctx.fillStyle = "rgba(150,150,150,0.35)";
          ctx.fillRect(left + igStart*pps, y0+6, igNext*pps, rowH-12);
        }
      }
    }
  });

  const info = document.getElementById('info');
  if(info) info.textContent = `Hidden T=${T}s · scale=${pps}px/s · canvas ${C.width}×${C.height}`;
  log('Hidden canvas redrawn (min-green enforced)','info');

  // --- TESTING: Bottom Clock A timeline (labels in seconds) ---
  (function(){
    try{
      const left = App.initCfg.plot.leftMargin || 120;
      const top  = App.initCfg.plot.topMargin || 24;
      const rowH = App.initCfg.plot.rowHeight || 48;
      const gap  = App.initCfg.plot.rowGap || 8;
      const pps  = App.state.pxPerSec || 4;
      const mult = (App.initCfg.plot && App.initCfg.plot.hiddenWindowMultiplier) || 5;
      const T    = App.state.mainCycle * mult; // full widened horizon
      const height = top + App.state.junctions.length*(rowH+gap) + 20;
      const stripH = 18;
      const yStrip = height - 6; // just above bottom padding

      // draw a white strip to stand out under the plot
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(left, yStrip - stripH + 2, (T*pps), stripH);

      ctx.fillStyle = '#444';
      ctx.font = '11px ui-monospace, Consolas, monospace';
      ctx.textBaseline = 'alphabetic';

      // Label every 10s along Clock A (0..T)
      for(let t=0;t<=T;t+=10){
        const x = left + t*pps;
        // tick
        ctx.beginPath();
        ctx.moveTo(x, yStrip - stripH + 2);
        ctx.lineTo(x, yStrip + 1);
        ctx.strokeStyle = '#bbb';
        ctx.lineWidth = 1;
        ctx.stroke();
        // text
        ctx.fillText(String(t)+'s', x+2, yStrip - 3);
      }
      ctx.restore();
    }catch(e){ console.warn('Clock A bottom timeline failed', e); }
  })();

}

// ---- transfer to visible (no extra logic; just blit a window) ----
function transferToVisible(){
  if(!(App.state.validOk && App.state.readyToPlot)){
    alert('Please Validate and Plot first.'); return;
  }
  const hidden = document.getElementById('hiddenCanvas');
  const visible = document.getElementById('visibleCanvas');
  const wrap = document.getElementById('visibleWrap');
  const pps = App.state.pxPerSec || 4;
  const M = App.state.mainCycle;
  const N = App.state.viewCycles || 2;
  const left = App.initCfg.plot.leftMargin || 120;
  const top = App.initCfg.plot.topMargin || 24;
  const Cj = M; // window cycles are based on main, starting at 1*C .. (1+N)*C
  const sx = left + 1*Cj*pps; // start at 1*C
  const sw = N*Cj*pps; // width of N cycles
  const sy = 0;
  const sh = hidden.height;
  // size visible to match the slice
  visible.width = sw;
  visible.height = sh;
  const vctx = visible.getContext('2d');
  vctx.clearRect(0,0,visible.width,visible.height);
  vctx.drawImage(hidden, sx, sy, sw, sh, 0, 0, sw, sh);
  log(`Transferred window: x=${sx}px w=${sw}px from hidden→visible (cycles 1..${1+N})`,'info');
}

function drawHiddenGate(){
  if(!App.state.validOk){ alert('Please Validate first.'); return; }
  App.state.readyToPlot = true;
  const p=document.getElementById('plotBtn'); if(p) p.classList.remove('dirty');
  const x=document.getElementById('transferBtn'); if(x) x.disabled=false;
  const chip=document.getElementById('statusChip'); if(chip) chip.textContent='Plotted ✓';
  log('Plot clicked — drawing (min-green enforced)','info');
  drawHidden();
}

// ---- UI rendering (same as v1.1.6) ----
function renderUTCEditor(j){
  let rows=''; (j.utcPlan||[]).forEach((r,i)=>{
    rows += `<tr>
      <td><select data-t="planTo" data-id="${j.id}" data-idx="${i}">
        ${j.stages.map(s=>`<option value="${s.label}" ${r.to===s.label?'selected':''}>${s.label}</option>`).join('')}
      </select></td>
      <td><input type="number" min="0" step="1" value="${r.at}" data-t="planAt" data-id="${j.id}" data-idx="${i}"></td>
      <td><button data-t="planDel" data-id="${j.id}" data-idx="${i}">Delete</button></td>
    </tr>`;
  });
  return `<h4>UTC Plan</h4>
  <table class="grid"><thead><tr><th>To stage</th><th>At (s)</th><th></th></tr></thead><tbody>${rows}</tbody></table>
  <button data-t="planAdd" data-id="${j.id}">Add change</button>`;
}

function renderJunctionPanel(j){
  const cfg = App.initCfg; const N=j.stages.length;
  let rows = '';
  for(let i=0;i<N;i++){
    rows += `<tr>
      <td><input data-t="stageLabel" data-id="${j.id}" data-idx="${i}" value="${j.stages[i].label}"></td>
      <td><input type="number" min="${cfg.stage.minGreen.min}" value="${j.stages[i].minGreenSec}" data-t="minGreen" data-id="${j.id}" data-idx="${i}"></td>
    </tr>`;
  }
  let ig = '<table class="grid"><thead><tr><th>From \\ To</th>';
  for(let c=0;c<N;c++){ ig += `<th>${j.stages[c].label}</th>`; }
  ig += '</tr></thead><tbody>';
  for(let r=0;r<N;r++){
    ig += `<tr><th>${j.stages[r].label}</th>`;
    for(let c=0;c<N;c++){
      if(r===c){ ig += `<td><input value="${cfg.intergreen.diagonalLockedValue}" disabled></td>`; }
      else{ ig += `<td><input type="number" step="1" min="-1" max="${cfg.intergreen.domain.max}" value="${j.intergreen[r][c]}" data-t="ig" data-id="${j.id}" data-r="${r}" data-c="${c}"></td>`; }
    }
    ig += '</tr>';
  }
  ig += '</tbody></table>';

  return `
    <div class="row">
      <label>Double cycle <input type="checkbox" data-t="double" data-id="${j.id}" ${j.doubleCycle?'checked':''}></label>
      <label>To previous (↑)<input type="number" min="${App.initCfg.journeyTime.min}" max="${App.initCfg.journeyTime.max}" value="${j.travelPrev}" data-t="travelPrev" data-id="${j.id}"></label>
      <label>To next (↓)<input type="number" min="${App.initCfg.journeyTime.min}" max="${App.initCfg.journeyTime.max}" value="${j.travelNext}" data-t="travelNext" data-id="${j.id}"></label>
      <label>Stage count<input type="number" min="${App.initCfg.stageCount.min}" max="8" value="${j.stages.length}" data-t="stageCount" data-id="${j.id}"></label>
    </div>
    <h4>Stages</h4>
    <table class="grid">
      <thead><tr><th>Label</th><th>Min green (s)</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
    <h4>Intergreen matrix (leading intergreen; -1 = not permitted)</h4>
    ${ig}
    ${renderUTCEditor(j)}
  `;
}

function rebuildTabs(){
  const tabs = document.getElementById('jtabs'); const panels = document.getElementById('tabpanels'); tabs.innerHTML=''; panels.innerHTML='';
  App.state.junctions.forEach((j, idx)=>{
    const t=document.createElement('button'); t.className='tab'+(idx===0?' active':''); t.textContent=j.name; t.dataset.id=j.id;
    t.addEventListener('click', ()=>{ document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active')); t.classList.add('active');
      document.querySelectorAll('.tabpanel').forEach(p=>p.classList.remove('active')); document.getElementById('tp_'+j.id).classList.add('active'); });
    tabs.appendChild(t);
    const tp=document.createElement('div'); tp.id='tp_'+j.id; tp.className='tabpanel'+(idx===0?' active':'');
    tp.innerHTML = renderJunctionPanel(j);
    panels.appendChild(tp);
  });
  wirePanelInputs();
  log('Junction tabs rendered','info');
}

function wirePanelInputs(){
  document.querySelectorAll('[data-t]').forEach(inp=>{
    const t=inp.getAttribute('data-t');
    if(t==='planAdd' || t==='planDel'){ inp.addEventListener('click', (e)=>{ onUTCEdit(e); setDirty(); }); }
    else{
      inp.addEventListener('change', (e)=>{ onPanelChange(e); setDirty(); });
      inp.addEventListener('blur',   (e)=>{ onPanelChange(e); setDirty(); });
    }
  });
}
function findJ(id){ return App.state.junctions.find(x=>x.id===id); }

function onUTCEdit(e){
  const t = e.target.getAttribute('data-t'); const id=e.target.getAttribute('data-id'); const j=findJ(id); if(!j) return;
  if(t==='planAdd'){ j.utcPlan.push({to:(j.stages[0]&&j.stages[0].label)||'S1', at:0}); rebuildTabs(); return; }
  if(t==='planDel'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan.splice(idx,1); rebuildTabs(); return; }
}

function onPanelChange(e){
  const t=e.target.getAttribute('data-t'); const id=e.target.getAttribute('data-id');
  const j=findJ(id); if(!j) return;
  if(t==='double'){ j.doubleCycle = e.target.checked; }
  if(t==='travelPrev'){ j.travelPrev = clampInt(e.target.value, App.initCfg.journeyTime.min, App.initCfg.journeyTime.max); e.target.value=j.travelPrev; }
  if(t==='travelNext'){ j.travelNext = clampInt(e.target.value, App.initCfg.journeyTime.min, App.initCfg.journeyTime.max); e.target.value=j.travelNext; }
  if(t==='stageCount'){ const n = Math.max(App.initCfg.stageCount.min, Math.min(8, parseInt(e.target.value||2,10))); resizeStages(j, n); rebuildTabs(); }
  if(t==='stageLabel'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].label = e.target.value|| ('S'+(idx+1)); rebuildTabs(); }
  if(t==='minGreen'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.stages[idx].minGreenSec = Math.max(App.initCfg.stage.minGreen.min, parseInt(e.target.value||App.initCfg.stage.minGreen.default,10)); e.target.value=j.stages[idx].minGreenSec; }
  if(t==='ig'){ const r=parseInt(e.target.getAttribute('data-r'),10), c=parseInt(e.target.getAttribute('data-c'),10);
    let v = parseInt(e.target.value||0,10); if(v!==-1) v = Math.max(App.initCfg.intergreen.domain.min, Math.min(App.initCfg.intergreen.domain.max, v));
    j.intergreen[r][c] = v; e.target.value = v; }
  if(t==='planTo'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan[idx].to = e.target.value; }
  if(t==='planAt'){ const idx=parseInt(e.target.getAttribute('data-idx'),10); j.utcPlan[idx].at = Math.max(0, parseInt(e.target.value||0,10)); }
}

function resizeStages(j, n){
  const minG = App.initCfg.stage.minGreen.default;
  while(j.stages.length < n){ j.stages.push({label:'S'+(j.stages.length+1), minGreenSec:minG}); }
  while(j.stages.length > n){ j.stages.pop(); }
  const N = j.stages.length;
  const igNew = [];
  for(let r=0;r<N;r++){ const row=[]; for(let c=0;c<N;c++){ row.push(r===c ? App.initCfg.intergreen.diagonalLockedValue : (j.intergreen[r] && typeof j.intergreen[r][c]==='number' ? j.intergreen[r][c] : App.initCfg.intergreen.defaults.offDiagonal)); } igNew.push(row); }
  j.intergreen = igNew;
  j.utcPlan.forEach(p=>{ if(!j.stages.find(s=>s.label===p.to)) p.to = j.stages[0].label; });
}

// ---- boot
async function boot(){
  App.initCfg = await loadBundledInit();
  const dock = document.getElementById('debugDock');
  if (App.initCfg.ui && App.initCfg.ui.debug && App.initCfg.ui.debug.enabled && App.initCfg.ui.debug.dock.showOnLoad) dock.style.display = 'block';
  document.getElementById('dbgClear').addEventListener('click', ()=>{ document.getElementById('log').textContent=''; });

  App.state = buildState(App.initCfg);
  document.getElementById('mainCycle').value = App.state.mainCycle;
  document.getElementById('jCount').value = App.state.junctions.length;
  document.getElementById('viewCycles').value = String(App.state.viewCycles);
  rebuildTabs();
  setDirty(); // force validation before any plot
  log('App booted — smoke-check…','info');

  // Boot-time smoke-check (silent)
  runValidation({silent:true});

  document.getElementById('mainCycle').addEventListener('change', (e)=>{
    const v=parseInt(e.target.value||60,10);
    const clamped=Math.max(App.initCfg.mainCycleTime.min, Math.min(App.initCfg.mainCycleTime.max, v));
    App.state.mainCycle=clamped; e.target.value=clamped; setDirty();
  });
  document.getElementById('jCount').addEventListener('change', (e)=>{
    const v=parseInt(e.target.value||3,10);
    const c=Math.max(App.initCfg.junctionCount.min, Math.min(App.initCfg.junctionCount.max, v));
    const cur=App.state.junctions.length; const ids=['A','B','C','D','E'];
    if(c>cur){ for(let i=cur;i<c;i++) App.state.junctions.push(mkJunction(ids[i], App.initCfg)); }
    else if(c<cur){ App.state.junctions.splice(c); }
    e.target.value=c; rebuildTabs(); setDirty();
  });
  document.getElementById('viewCycles').addEventListener('change', (e)=>{ App.state.viewCycles=parseInt(e.target.value||2,10); setDirty(); });

  document.getElementById('validateBtn').addEventListener('click', ()=>{ runValidation({silent:false}); });
  document.getElementById('plotBtn').addEventListener('click', ()=>{
    if(!App.state.validOk){ alert('Please Validate first.'); return; }
    App.state.readyToPlot = true;
    const p=document.getElementById('plotBtn'); if(p) p.classList.remove('dirty');
    const x=document.getElementById('transferBtn'); if(x) x.disabled=false;
    const chip=document.getElementById('statusChip'); if(chip) chip.textContent='Plotted ✓';
    log('Plot clicked — drawing (hidden)','info');
    drawHidden();
  });
  document.getElementById('transferBtn').addEventListener('click', transferToVisible);

  const zoom = document.getElementById('zoom');
  if(zoom){ zoom.value = String(App.state.pxPerSec||4); zoom.addEventListener('input', ()=>{ App.state.pxPerSec=parseInt(zoom.value,10); drawHidden(); }); }
  const fit = document.getElementById('fitBtn');
  if(fit){ fit.addEventListener('click', ()=>{
    const wrap=document.getElementById('hiddenWrap');
    const M=App.state.mainCycle; const mult=App.initCfg.plot.hiddenWindowMultiplier||5; const T=M*mult;
    const lm=App.initCfg.plot.leftMargin||120; const rightPad=20; const usable=Math.max(100, wrap.clientWidth - lm - rightPad);
    const pps=Math.max(1, Math.floor(usable/Math.max(1,T)));
    App.state.pxPerSec=pps; if(zoom) zoom.value=String(pps); drawHidden();
  }); }
}
boot();
</script>

<script>
// ---- Master Tabs (robust) ----
(function(){
  function byId(id){ return document.getElementById(id); }
  const panels = byId('tabPanels');
  const tabData = byId('tab-data');
  const tabHidden = byId('tab-hidden');
  if(!panels || !tabData || !tabHidden) return;

  // Move known canvas wrapper to Hidden tab
  const hiddenWrap = byId('hiddenWrap') || (function(){
    // Try to find hiddenCanvas and wrap it if needed
    const hc = byId('hiddenCanvas');
    if(!hc) return null;
    const wrap = document.createElement('div');
    wrap.id = 'hiddenWrap';
    wrap.style.overflow = 'auto';
    hc.parentNode.insertBefore(wrap, hc);
    wrap.appendChild(hc);
    return wrap;
  })();

  if(hiddenWrap && hiddenWrap.parentElement !== tabHidden){
    tabHidden.appendChild(hiddenWrap);
  }

  // Move other non-tab content into Data tab (except our tabs container/panels)
  const masterTabs = byId('masterTabs');
  const children = Array.from(document.body.children);
  children.forEach(node=>{
    if(node===masterTabs || node===panels || node.id==='tab-data' || node.id==='tab-hidden') return;
    if(node.id==='hiddenWrap') return;
    tabData.appendChild(node);
  });

  // Click handlers
  function activate(tab){
    ['data','hidden'].forEach(t=>{
      const btn = document.querySelector('.tabbtn[data-tab="'+t+'"]');
      const sec = byId('tab-'+t);
      if(!btn || !sec) return;
      const active = (t===tab);
      sec.style.display = active ? 'block' : 'none';
      btn.style.background = active ? '#fff' : '#eee';
      btn.style.borderBottom = active ? '1px solid #fff' : '1px solid #ccc';
    });
    if(tab==='hidden'){
      try{ if(typeof fitToViewCycles==='function') fitToViewCycles(); }catch(e){}
    }
  }
  document.querySelectorAll('.tabbtn').forEach(btn=>{
    btn.addEventListener('click', ()=> activate(btn.getAttribute('data-tab')));
  });
  // Default
  activate('data');
})();
</script>


<script>
// --- Zoom handler for hidden canvas ---
(function(){
  const wrap = document.getElementById('hiddenWrap');
  if(!wrap) return;
  wrap.addEventListener('wheel', (ev)=>{
    if(!(ev.ctrlKey || ev.metaKey)) return;
    ev.preventDefault();
    const rect = wrap.getBoundingClientRect();
    const cx = ev.clientX - rect.left + wrap.scrollLeft;
    const old = App.state.pxPerSec || 4;
    const minP = 1, maxP = 20;
    const f = (ev.deltaY < 0) ? 1.1 : 0.9;
    let next = Math.max(minP, Math.min(maxP, Math.round(old * f)));
    if(next === old) return;
    const left = (App.initCfg.plot && App.initCfg.plot.leftMargin) || 120;
    const t_before = Math.max(0, (cx - left) / old);
    App.state.pxPerSec = next;
    const z = document.getElementById('zoom'); if(z) z.value = String(next);
    if(typeof drawHidden==='function') drawHidden();
    const t_px_after = left + t_before * next;
    wrap.scrollLeft = Math.max(0, t_px_after - (ev.clientX - rect.left));
  }, {passive:false});
})();
</script>


<script>
function fitToViewCycles(){
  try{
    const wrap = document.getElementById('hiddenWrap');
    if(!wrap) return;
    const M = App.state.mainCycle;
    const N = App.state.viewCycles || 2;
    const left = (App.initCfg.plot && App.initCfg.plot.leftMargin) || 120;
    const rightPad = 20;
    const usable = Math.max(100, (wrap.clientWidth||wrap.offsetWidth) - left - rightPad);
    const pps = Math.max(1, Math.floor(usable / Math.max(1, N * M)));
    App.state.pxPerSec = pps;
    const zoom = document.getElementById('zoom'); if(zoom) zoom.value = String(pps);
    if(typeof drawHidden==='function') drawHidden();
  }catch(e){ console.warn('fitToViewCycles failed', e); }
}
</script>


<script>
// Hook view cycles change -> fit canvas width
(function(){
  var vc = document.querySelector('[data-key="plot.viewCycles"]') || document.getElementById('viewCycles');
  if(vc){
    vc.addEventListener('change', function(){
      var n = parseInt(vc.value, 10);
      if(!isNaN(n)){ App.state.viewCycles = n; }
      fitToViewCycles();
    });
  }
  window.addEventListener('resize', function(){ fitToViewCycles(); });
})();
</script>

</body>
</html>
